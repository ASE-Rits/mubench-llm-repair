# Project: alibaba-druid / Case: 2

## original.java -> misuse.java
-import java.security.interfaces.RSAPrivateKey;
-import java.security.spec.RSAPublicKeySpec;
-            // 因为 IBM JDK 不支持私钥加密, 公钥解密, 所以要反转公私钥
-            // 也就是说对于解密, 可以通过公钥的参数伪造一个私钥对象欺骗 IBM JDK
-            RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
-            RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
-            Key fakePrivateKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
-            cipher = Cipher.getInstance("RSA"); //It is a stateful object. so we need to get new one.
-            cipher.init(Cipher.DECRYPT_MODE, fakePrivateKey);
+			// for ibm jdk
+			RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
+			RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
+			Key fakePublicKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
+			cipher.init(Cipher.DECRYPT_MODE, fakePublicKey);
-        try {
-		    cipher.init(Cipher.ENCRYPT_MODE, privateKey);
-        } catch (InvalidKeyException e) {
-            //For IBM JDK, 原因请看解密方法中的说明
-            RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;
-            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(rsaPrivateKey.getModulus(), rsaPrivateKey.getPrivateExponent());
-            Key publicKey = KeyFactory.getInstance("RSA").generatePublic(publicKeySpec);
-            cipher = Cipher.getInstance("RSA");
-            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
-        }
+		cipher.init(Cipher.ENCRYPT_MODE, privateKey);

## misuse.java -> fixed.java
+import java.nio.charset.StandardCharsets;
+import java.security.GeneralSecurityException;
+
+
+
+
-		
+
-		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
-		KeyFactory factory = KeyFactory.getInstance("RSA");
-		PrivateKey privateKey = factory.generatePrivate(spec);
-		Cipher cipher = Cipher.getInstance("RSA");
-		cipher.init(Cipher.ENCRYPT_MODE, privateKey);
-
-		byte[] encryptedBytes = cipher.doFinal(plainText.getBytes("UTF-8"));
-		String encryptedString = Base64.byteArrayToBase64(encryptedBytes);
-
-		return encryptedString;
+		try {
+			PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
+			KeyFactory factory = KeyFactory.getInstance("RSA");
+			PrivateKey privateKey = factory.generatePrivate(spec);
+			Cipher cipher = Cipher.getInstance("RSA");
+			cipher.init(Cipher.ENCRYPT_MODE, privateKey);
+			byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
+			return Base64.byteArrayToBase64(encryptedBytes);
+		} catch (GeneralSecurityException e) {
+			throw new IllegalArgumentException("Failed to encrypt", e);
+		}

## original.java -> fixed.java
+import java.nio.charset.StandardCharsets;
+import java.security.GeneralSecurityException;
-import java.security.interfaces.RSAPrivateKey;
+
-import java.security.spec.RSAPublicKeySpec;
+
-            // 因为 IBM JDK 不支持私钥加密, 公钥解密, 所以要反转公私钥
-            // 也就是说对于解密, 可以通过公钥的参数伪造一个私钥对象欺骗 IBM JDK
-            RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
-            RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
-            Key fakePrivateKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
-            cipher = Cipher.getInstance("RSA"); //It is a stateful object. so we need to get new one.
-            cipher.init(Cipher.DECRYPT_MODE, fakePrivateKey);
+			// for ibm jdk
+			RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
+			RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
+			Key fakePublicKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
+			cipher.init(Cipher.DECRYPT_MODE, fakePublicKey);
+
+
-		
+
-		PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
-		KeyFactory factory = KeyFactory.getInstance("RSA");
-		PrivateKey privateKey = factory.generatePrivate(spec);
-		Cipher cipher = Cipher.getInstance("RSA");
-        try {
-		    cipher.init(Cipher.ENCRYPT_MODE, privateKey);
-        } catch (InvalidKeyException e) {
-            //For IBM JDK, 原因请看解密方法中的说明
-            RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;
-            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(rsaPrivateKey.getModulus(), rsaPrivateKey.getPrivateExponent());
-            Key publicKey = KeyFactory.getInstance("RSA").generatePublic(publicKeySpec);
-            cipher = Cipher.getInstance("RSA");
-            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
-        }
-
-		byte[] encryptedBytes = cipher.doFinal(plainText.getBytes("UTF-8"));
-		String encryptedString = Base64.byteArrayToBase64(encryptedBytes);
-
-		return encryptedString;
+		try {
+			PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
+			KeyFactory factory = KeyFactory.getInstance("RSA");
+			PrivateKey privateKey = factory.generatePrivate(spec);
+			Cipher cipher = Cipher.getInstance("RSA");
+			cipher.init(Cipher.ENCRYPT_MODE, privateKey);
+			byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
+			return Base64.byteArrayToBase64(encryptedBytes);
+		} catch (GeneralSecurityException e) {
+			throw new IllegalArgumentException("Failed to encrypt", e);
+		}
