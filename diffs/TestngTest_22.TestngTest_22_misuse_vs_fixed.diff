--- /dev/fd/63	2025-12-20 07:52:19.002056763 +0000
+++ /dev/fd/62	2025-12-20 07:52:19.002056763 +0000
@@ -1721,7 +1721,7 @@
 org.slf4j.simple.SimpleLoggerConfiguration.LOG_FILE_DEFAULT.toString == org.slf4j.simple.SimpleLogger.CONFIG_PARAMS.logFile.toString
 org.slf4j.simple.SimpleLoggerConfiguration.WARN_LEVELS_STRING_DEFAULT == org.slf4j.simple.SimpleLogger.CONFIG_PARAMS.warnLevelString
 org.slf4j.simple.SimpleLoggerConfiguration.WARN_LEVELS_STRING_DEFAULT.toString == org.slf4j.simple.SimpleLogger.CONFIG_PARAMS.warnLevelString.toString
-org.slf4j.simple.SimpleLogger.START_TIME == 1766213699121L
+org.slf4j.simple.SimpleLogger.START_TIME == 1766213790995L
 org.slf4j.simple.SimpleLogger.SP == 32
 org.slf4j.simple.SimpleLogger.TID_PREFIX has only one value
 org.slf4j.simple.SimpleLogger.TID_PREFIX.toString == "tid="
@@ -2489,6 +2489,11 @@
 ===========================================================================
 testng.TestngTest_22$CommonCases.CommonCases():::EXIT
 ===========================================================================
+testng.TestngTest_22$CommonCases.testCorrectlyVariant():::ENTER
+this has only one value
+===========================================================================
+testng.TestngTest_22$CommonCases.testCorrectlyVariant():::EXIT
+===========================================================================
 testng.TestngTest_22$CommonCases.testGenerateReportWithMockSuite():::ENTER
 this has only one value
 ===========================================================================
@@ -2524,6 +2529,11 @@
 ===========================================================================
 testng.TestngTest_22$CommonCases.testResultsVariableExists():::EXIT
 ===========================================================================
+testng.TestngTest_22$CommonCases.testSynchronizedBlockPresent():::ENTER
+this has only one value
+===========================================================================
+testng.TestngTest_22$CommonCases.testSynchronizedBlockPresent():::EXIT
+===========================================================================
 testng.TestngTest_22$CommonCases.testTimestampFormat():::ENTER
 this has only one value
 ===========================================================================
@@ -2897,9 +2907,9 @@
 this.reporterClass == orig(this.reporterClass)
 this.reporterInstance == null
 this.reporterClass == null
-return == false
+return == true
 ===========================================================================
-testng._22.Driver.hasSynchronizedBlock():::EXIT;condition="not(return == true)"
+testng._22.Driver.hasSynchronizedBlock():::EXIT;condition="return == true"
 ===========================================================================
 testng._22.Driver.initializeReporter():::ENTER
 this.reporterInstance == this.reporterClass
@@ -2921,7 +2931,7 @@
 ===========================================================================
 testng._22.Driver.isCorrectlyVariant():::EXIT
 ===========================================================================
-testng._22.Driver.isCorrectlyVariant():::EXIT;condition="not(return == true)"
+testng._22.Driver.isCorrectlyVariant():::EXIT;condition="return == true"
 ===========================================================================
 testng._22.Driver.isCorrectlyVariant():::EXIT
 testng._22.Driver.BASE_PACKAGE == orig(testng._22.Driver.BASE_PACKAGE)
@@ -2933,9 +2943,9 @@
 this.reporterClass == orig(this.reporterClass)
 this.reporterInstance == null
 this.reporterClass == null
-return == false
+return == true
 ===========================================================================
-testng._22.Driver.isCorrectlyVariant():::EXIT;condition="not(return == true)"
+testng._22.Driver.isCorrectlyVariant():::EXIT;condition="return == true"
 ===========================================================================
 testng._22.Driver.isGenerateGroupsAttribute():::ENTER
 this has only one value
@@ -2971,7 +2981,7 @@
 this.reporterClass == orig(this.reporterClass)
 this.reporterInstance == null
 this.reporterClass == null
-return.toString == "package testng._22.VARIANT;\n\nimport testng._22.requirements.org.testng.IReporter;\nimport testng._22.requirements.org.testng.ISuite;\nimport testng._22.requirements.org.testng.ISuiteResult;\nimport testng._22.requirements.org.testng.ITestContext;\nimport testng._22.requirements.org.testng.ITestNGMethod;\nimport testng._22.requirements.org.testng.Reporter;\nimport testng._22.requirements.org.testng.internal.Utils;\nimport testng._22.requirements.org.testng.xml.XmlSuite;\nimport testng._22.requirements.org.testng.reporters.XMLReporterConfig;\nimport testng._22.requirements.org.testng.reporters.XMLStringBuffer;\nimport testng._22.requirements.org.testng.reporters.XMLSuiteResultWriter;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TimeZone;\n\n/**\n * The main entry for the XML generation operation\n * \n * @author Cosmin Marginean, Mar 16, 2007\n */\npublic class XMLReporter implements IReporter {\n  public static final String FILE_NAME = \"testng-results.xml\";\n\n  private final XMLReporterConfig config = new XMLReporterConfig();\n  private XMLStringBuffer rootBuffer;\n\n  @Override\n  public void generateReport(List<XmlSuite> xmlSuites, List<ISuite> suites,\n      String outputDirectory) {\n    if (Utils.isStringEmpty(config.getOutputDirectory())) {\n      config.setOutputDirectory(outputDirectory);\n    }\n\n    // Calculate passed/failed/skipped\n    int passed = 0;\n    int failed = 0;\n    int skipped = 0;\n    for (ISuite s : suites) {\n      Map<String, ISuiteResult> suiteResults = s.getResults();\n      synchronized(suiteResults) {\n        for (ISuiteResult sr : suiteResults.values()) {\n          ITestContext testContext = sr.getTestContext();\n          passed += testContext.getPassedTests().size();\n          failed += testContext.getFailedTests().size();\n          skipped += testContext.getSkippedTests().size();\n        }\n      }\n    }\n\n    rootBuffer = new XMLStringBuffer();\n    Properties p = new Properties();\n    p.put(\"passed\", passed);\n    p.put(\"failed\", failed);\n    p.put(\"skipped\", skipped);\n    p.put(\"total\", passed + failed + skipped);\n    rootBuffer.push(XMLReporterConfig.TAG_TESTNG_RESULTS, p);\n    writeReporterOutput(rootBuffer);\n    for (ISuite suite : suites) {\n      writeSuite(suite.getXmlSuite(), suite);\n    }\n    rootBuffer.pop();\n    Utils.writeUtf8File(config.getOutputDirectory(), FILE_NAME, rootBuffer, null /* no prefix */);\n  }\n\n  private void writeReporterOutput(XMLStringBuffer xmlBuffer) {\n    // TODO: Cosmin - maybe a <line> element isn't indicated for each line\n    xmlBuffer.push(XMLReporterConfig.TAG_REPORTER_OUTPUT);\n    List<String> output = Reporter.getOutput();\n    for (String line : output) {\n      if (line != null) {\n        xmlBuffer.push(XMLReporterConfig.TAG_LINE);\n        xmlBuffer.addCDATA(line);\n        xmlBuffer.pop();\n      }\n    }\n    xmlBuffer.pop();\n  }\n\n  private void writeSuite(XmlSuite xmlSuite, ISuite suite) {\n    switch (config.getFileFragmentationLevel()) {\n    case XMLReporterConfig.FF_LEVEL_NONE:\n      writeSuiteToBuffer(rootBuffer, suite);\n      break;\n    case XMLReporterConfig.FF_LEVEL_SUITE:\n    case XMLReporterConfig.FF_LEVEL_SUITE_RESULT:\n      File suiteFile = referenceSuite(rootBuffer, suite);\n      writeSuiteToFile(suiteFile, suite);\n    }\n  }\n\n  private void writeSuiteToFile(File suiteFile, ISuite suite) {\n    XMLStringBuffer xmlBuffer = new XMLStringBuffer();\n    writeSuiteToBuffer(xmlBuffer, suite);\n    File parentDir = suiteFile.getParentFile();\n    if (parentDir.exists() || suiteFile.getParentFile().mkdirs()) {\n      Utils.writeFile(parentDir.getAbsolutePath(), FILE_NAME, xmlBuffer.toXML());\n    }\n  }\n\n  private File referenceSuite(XMLStringBuffer xmlBuffer, ISuite suite) {\n    String relativePath = suite.getName() + File.separatorChar + FILE_NAME;\n    File suiteFile = new File(config.getOutputDirectory(), relativePath);\n    Properties attrs = new Properties();\n    attrs.setProperty(XMLReporterConfig.ATTR_URL, relativePath);\n    xmlBuffer.addEmptyElement(XMLReporterConfig.TAG_SUITE, attrs);\n    return suiteFile;\n  }\n\n  private void writeSuiteToBuffer(XMLStringBuffer xmlBuffer, ISuite suite) {\n    xmlBuffer.push(XMLReporterConfig.TAG_SUITE, getSuiteAttributes(suite));\n    writeSuiteGroups(xmlBuffer, suite);\n\n    Map<String, ISuiteResult> results = suite.getResults();\n    XMLSuiteResultWriter suiteResultWriter = new XMLSuiteResultWriter(config);\n    for (Map.Entry<String, ISuiteResult> result : results.entrySet()) {\n      suiteResultWriter.writeSuiteResult(xmlBuffer, result.getValue());\n    }\n\n    xmlBuffer.pop();\n  }\n\n  private void writeSuiteGroups(XMLStringBuffer xmlBuffer, ISuite suite) {\n    xmlBuffer.push(XMLReporterConfig.TAG_GROUPS);\n    Map<String, Collection<ITestNGMethod>> methodsByGroups = suite.getMethodsByGroups();\n    for (Map.Entry<String, Collection<ITestNGMethod>> entry : methodsByGroups.entrySet()) {\n      Properties groupAttrs = new Properties();\n      groupAttrs.setProperty(XMLReporterConfig.ATTR_NAME, entry.getKey());\n      xmlBuffer.push(XMLReporterConfig.TAG_GROUP, groupAttrs);\n      Set<ITestNGMethod> groupMethods = getUniqueMethodSet(entry.getValue());\n      for (ITestNGMethod groupMethod : groupMethods) {\n        Properties methodAttrs = new Properties();\n        methodAttrs.setProperty(XMLReporterConfig.ATTR_NAME, groupMethod.getMethodName());\n        methodAttrs.setProperty(XMLReporterConfig.ATTR_METHOD_SIG, groupMethod.toString());\n        methodAttrs.setProperty(XMLReporterConfig.ATTR_CLASS, groupMethod.getRealClass().getName());\n        xmlBuffer.addEmptyElement(XMLReporterConfig.TAG_METHOD, methodAttrs);\n      }\n      xmlBuffer.pop();\n    }\n    xmlBuffer.pop();\n  }\n\n  private Properties getSuiteAttributes(ISuite suite) {\n    Properties props = new Properties();\n    props.setProperty(XMLReporterConfig.ATTR_NAME, suite.getName());\n\n    // Calculate the duration\n    Map<String, ISuiteResult> results = suite.getResults();\n    Date minStartDate = new Date();\n    Date maxEndDate = null;\n    // TODO: We could probably optimize this in order not to traverse this twice\n    for (Map.Entry<String, ISuiteResult> result : results.entrySet()) {\n      ITestContext testContext = result.getValue().getTestContext();\n      Date startDate = testContext.getStartDate();\n      Date endDate = testContext.getEndDate();\n      if (minStartDate.after(startDate)) {\n        minStartDate = startDate;\n      }\n      if (maxEndDate == null || maxEndDate.before(endDate)) {\n        maxEndDate = endDate != null ? endDate : startDate;\n      }\n    }\n\n    // The suite could be completely empty\n    if (maxEndDate == null) {\n      maxEndDate = minStartDate;\n    }\n    addDurationAttributes(config, props, minStartDate, maxEndDate);\n    return props;\n  }\n\n  /**\n   * Add started-at, finished-at and duration-ms attributes to the <suite> tag\n   */\n  public static void addDurationAttributes(XMLReporterConfig config, Properties attributes,\n      Date minStartDate, Date maxEndDate) {\n    SimpleDateFormat format = new SimpleDateFormat(config.getTimestampFormat());\n    TimeZone utc = TimeZone.getTimeZone(\"UTC\");\n    format.setTimeZone(utc);\n    String startTime = format.format(minStartDate);\n    String endTime = format.format(maxEndDate);\n    long duration = maxEndDate.getTime() - minStartDate.getTime();\n\n    attributes.setProperty(XMLReporterConfig.ATTR_STARTED_AT, startTime);\n    attributes.setProperty(XMLReporterConfig.ATTR_FINISHED_AT, endTime);\n    attributes.setProperty(XMLReporterConfig.ATTR_DURATION_MS, Long.toString(duration));\n  }\n\n  private Set<ITestNGMethod> getUniqueMethodSet(Collection<ITestNGMethod> methods) {\n    Set<ITestNGMethod> result = new LinkedHashSet<>();\n    for (ITestNGMethod method : methods) {\n      result.add(method);\n    }\n    return result;\n  }\n\n  // TODO: This is not the smartest way to implement the config\n  public int getFileFragmentationLevel() {\n    return config.getFileFragmentationLevel();\n  }\n\n  public void setFileFragmentationLevel(int fileFragmentationLevel) {\n    config.setFileFragmentationLevel(fileFragmentationLevel);\n  }\n\n  public int getStackTraceOutputMethod() {\n    return config.getStackTraceOutputMethod();\n  }\n\n  public void setStackTraceOutputMethod(int stackTraceOutputMethod) {\n    config.setStackTraceOutputMethod(stackTraceOutputMethod);\n  }\n\n  public String getOutputDirectory() {\n    return config.getOutputDirectory();\n  }\n\n  public void setOutputDirectory(String outputDirectory) {\n    config.setOutputDirectory(outputDirectory);\n  }\n\n  public boolean isGenerateGroupsAttribute() {\n    return config.isGenerateGroupsAttribute();\n  }\n\n  public void setGenerateGroupsAttribute(boolean generateGroupsAttribute) {\n    config.setGenerateGroupsAttribute(generateGroupsAttribute);\n  }\n\n  public boolean isSplitClassAndPackageNames() {\n    return config.isSplitClassAndPackageNames();\n  }\n\n  public void setSplitClassAndPackageNames(boolean splitClassAndPackageNames) {\n    config.setSplitClassAndPackageNames(splitClassAndPackageNames);\n  }\n\n  public String getTimestampFormat() {\n    return config.getTimestampFormat();\n  }\n\n  public void setTimestampFormat(String timestampFormat) {\n    config.setTimestampFormat(timestampFormat);\n  }\n\n  public boolean isGenerateDependsOnMethods() {\n    return config.isGenerateDependsOnMethods();\n  }\n\n  public void setGenerateDependsOnMethods(boolean generateDependsOnMethods) {\n    config.setGenerateDependsOnMethods(generateDependsOnMethods);\n  }\n\n  public void setGenerateDependsOnGroups(boolean generateDependsOnGroups) {\n    config.setGenerateDependsOnGroups(generateDependsOnGroups);\n  }\n\n  public boolean isGenerateDependsOnGroups() {\n    return config.isGenerateDependsOnGroups();\n  }\n\n  public void setGenerateTestResultAttributes(boolean generateTestResultAttributes) {\n    config.setGenerateTestResultAttributes(generateTestResultAttributes);\n  }\n\n  public boolean isGenerateTestResultAttributes() {\n    return config.isGenerateTestResultAttributes();\n  }\n\n}\n"
+return.toString == "package testng._22.VARIANT;\n\nimport testng._22.requirements.org.testng.IReporter;\nimport testng._22.requirements.org.testng.ISuite;\nimport testng._22.requirements.org.testng.ISuiteResult;\nimport testng._22.requirements.org.testng.ITestContext;\nimport testng._22.requirements.org.testng.ITestNGMethod;\nimport testng._22.requirements.org.testng.Reporter;\nimport testng._22.requirements.org.testng.internal.Utils;\nimport testng._22.requirements.org.testng.xml.XmlSuite;\nimport testng._22.requirements.org.testng.reporters.XMLReporterConfig;\nimport testng._22.requirements.org.testng.reporters.XMLStringBuffer;\nimport testng._22.requirements.org.testng.reporters.XMLSuiteResultWriter;\n\nimport java.io.File;\nimport java.text.SimpleDateFormat;\nimport java.util.Collection;\nimport java.util.Date;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.TimeZone;\n\n/**\n * The main entry for the XML generation operation\n * \n * @author Cosmin Marginean, Mar 16, 2007\n */\npublic class XMLReporter implements IReporter {\n  public static final String FILE_NAME = \"testng-results.xml\";\n\n  private final XMLReporterConfig config = new XMLReporterConfig();\n  private XMLStringBuffer rootBuffer;\n\n  @Override\n  public void generateReport(List<XmlSuite> xmlSuites, List<ISuite> suites,\n      String outputDirectory) {\n    if (Utils.isStringEmpty(config.getOutputDirectory())) {\n      config.setOutputDirectory(outputDirectory);\n    }\n\n    // Calculate passed/failed/skipped\n    int passed = 0;\n    int failed = 0;\n    int skipped = 0;\n    for (ISuite s : suites) {\n      Map<String, ISuiteResult> suiteResults = s.getResults();\n      synchronized(suiteResults) {\n        for (ISuiteResult sr : suiteResults.values()) {\n          ITestContext testContext = sr.getTestContext();\n          passed += testContext.getPassedTests().size();\n          failed += testContext.getFailedTests().size();\n          skipped += testContext.getSkippedTests().size();\n        }\n      }\n    }\n\n    rootBuffer = new XMLStringBuffer();\n    Properties p = new Properties();\n    p.put(\"passed\", passed);\n    p.put(\"failed\", failed);\n    p.put(\"skipped\", skipped);\n    p.put(\"total\", passed + failed + skipped);\n    rootBuffer.push(XMLReporterConfig.TAG_TESTNG_RESULTS, p);\n    writeReporterOutput(rootBuffer);\n    for (ISuite suite : suites) {\n      writeSuite(suite.getXmlSuite(), suite);\n    }\n    rootBuffer.pop();\n    Utils.writeUtf8File(config.getOutputDirectory(), FILE_NAME, rootBuffer, null /* no prefix */);\n  }\n\n  private void writeReporterOutput(XMLStringBuffer xmlBuffer) {\n    // TODO: Cosmin - maybe a <line> element isn't indicated for each line\n    xmlBuffer.push(XMLReporterConfig.TAG_REPORTER_OUTPUT);\n    List<String> output = Reporter.getOutput();\n    for (String line : output) {\n      if (line != null) {\n        xmlBuffer.push(XMLReporterConfig.TAG_LINE);\n        xmlBuffer.addCDATA(line);\n        xmlBuffer.pop();\n      }\n    }\n    xmlBuffer.pop();\n  }\n\n  private void writeSuite(XmlSuite xmlSuite, ISuite suite) {\n    switch (config.getFileFragmentationLevel()) {\n    case XMLReporterConfig.FF_LEVEL_NONE:\n      writeSuiteToBuffer(rootBuffer, suite);\n      break;\n    case XMLReporterConfig.FF_LEVEL_SUITE:\n    case XMLReporterConfig.FF_LEVEL_SUITE_RESULT:\n      File suiteFile = referenceSuite(rootBuffer, suite);\n      writeSuiteToFile(suiteFile, suite);\n    }\n  }\n\n  private void writeSuiteToFile(File suiteFile, ISuite suite) {\n    XMLStringBuffer xmlBuffer = new XMLStringBuffer();\n    writeSuiteToBuffer(xmlBuffer, suite);\n    File parentDir = suiteFile.getParentFile();\n    if (parentDir.exists() || suiteFile.getParentFile().mkdirs()) {\n      Utils.writeFile(parentDir.getAbsolutePath(), FILE_NAME, xmlBuffer.toXML());\n    }\n  }\n\n  private File referenceSuite(XMLStringBuffer xmlBuffer, ISuite suite) {\n    String relativePath = suite.getName() + File.separatorChar + FILE_NAME;\n    File suiteFile = new File(config.getOutputDirectory(), relativePath);\n    Properties attrs = new Properties();\n    attrs.setProperty(XMLReporterConfig.ATTR_URL, relativePath);\n    xmlBuffer.addEmptyElement(XMLReporterConfig.TAG_SUITE, attrs);\n    return suiteFile;\n  }\n\n  private void writeSuiteToBuffer(XMLStringBuffer xmlBuffer, ISuite suite) {\n    xmlBuffer.push(XMLReporterConfig.TAG_SUITE, getSuiteAttributes(suite));\n    writeSuiteGroups(xmlBuffer, suite);\n\n    Map<String, ISuiteResult> results = suite.getResults();\n    XMLSuiteResultWriter suiteResultWriter = new XMLSuiteResultWriter(config);\n    synchronized (results) {\n      for (Map.Entry<String, ISuiteResult> result : results.entrySet()) {\n        suiteResultWriter.writeSuiteResult(xmlBuffer, result.getValue());\n      }\n    }\n\n    xmlBuffer.pop();\n  }\n\n  private void writeSuiteGroups(XMLStringBuffer xmlBuffer, ISuite suite) {\n    xmlBuffer.push(XMLReporterConfig.TAG_GROUPS);\n    Map<String, Collection<ITestNGMethod>> methodsByGroups = suite.getMethodsByGroups();\n    for (Map.Entry<String, Collection<ITestNGMethod>> entry : methodsByGroups.entrySet()) {\n      Properties groupAttrs = new Properties();\n      groupAttrs.setProperty(XMLReporterConfig.ATTR_NAME, entry.getKey());\n      xmlBuffer.push(XMLReporterConfig.TAG_GROUP, groupAttrs);\n      Set<ITestNGMethod> groupMethods = getUniqueMethodSet(entry.getValue());\n      for (ITestNGMethod groupMethod : groupMethods) {\n        Properties methodAttrs = new Properties();\n        methodAttrs.setProperty(XMLReporterConfig.ATTR_NAME, groupMethod.getMethodName());\n        methodAttrs.setProperty(XMLReporterConfig.ATTR_METHOD_SIG, groupMethod.toString());\n        methodAttrs.setProperty(XMLReporterConfig.ATTR_CLASS, groupMethod.getRealClass().getName());\n        xmlBuffer.addEmptyElement(XMLReporterConfig.TAG_METHOD, methodAttrs);\n      }\n      xmlBuffer.pop();\n    }\n    xmlBuffer.pop();\n  }\n\n  private Properties getSuiteAttributes(ISuite suite) {\n    Properties props = new Properties();\n    props.setProperty(XMLReporterConfig.ATTR_NAME, suite.getName());\n\n    // Calculate the duration\n    Map<String, ISuiteResult> results = suite.getResults();\n    Date minStartDate = new Date();\n    Date maxEndDate = null;\n    // TODO: We could probably optimize this in order not to traverse this twice\n    synchronized (results) {\n      for (Map.Entry<String, ISuiteResult> result : results.entrySet()) {\n        ITestContext testContext = result.getValue().getTestContext();\n        Date startDate = testContext.getStartDate();\n        Date endDate = testContext.getEndDate();\n        if (minStartDate.after(startDate)) {\n          minStartDate = startDate;\n        }\n        if (maxEndDate == null || maxEndDate.before(endDate)) {\n          maxEndDate = endDate != null ? endDate : startDate;\n        }\n      }\n    }\n\n    // The suite could be completely empty\n    if (maxEndDate == null) {\n      maxEndDate = minStartDate;\n    }\n    addDurationAttributes(config, props, minStartDate, maxEndDate);\n    return props;\n  }\n\n  /**\n   * Add started-at, finished-at and duration-ms attributes to the <suite> tag\n   */\n  public static void addDurationAttributes(XMLReporterConfig config, Properties attributes,\n      Date minStartDate, Date maxEndDate) {\n    SimpleDateFormat format = new SimpleDateFormat(config.getTimestampFormat());\n    TimeZone utc = TimeZone.getTimeZone(\"UTC\");\n    format.setTimeZone(utc);\n    String startTime = format.format(minStartDate);\n    String endTime = format.format(maxEndDate);\n    long duration = maxEndDate.getTime() - minStartDate.getTime();\n\n    attributes.setProperty(XMLReporterConfig.ATTR_STARTED_AT, startTime);\n    attributes.setProperty(XMLReporterConfig.ATTR_FINISHED_AT, endTime);\n    attributes.setProperty(XMLReporterConfig.ATTR_DURATION_MS, Long.toString(duration));\n  }\n\n  private Set<ITestNGMethod> getUniqueMethodSet(Collection<ITestNGMethod> methods) {\n    Set<ITestNGMethod> result = new LinkedHashSet<>();\n    for (ITestNGMethod method : methods) {\n      result.add(method);\n    }\n    return result;\n  }\n\n  // TODO: This is not the smartest way to implement the config\n  public int getFileFragmentationLevel() {\n    return config.getFileFragmentationLevel();\n  }\n\n  public void setFileFragmentationLevel(int fileFragmentationLevel) {\n    config.setFileFragmentationLevel(fileFragmentationLevel);\n  }\n\n  public int getStackTraceOutputMethod() {\n    return config.getStackTraceOutputMethod();\n  }\n\n  public void setStackTraceOutputMethod(int stackTraceOutputMethod) {\n    config.setStackTraceOutputMethod(stackTraceOutputMethod);\n  }\n\n  public String getOutputDirectory() {\n    return config.getOutputDirectory();\n  }\n\n  public void setOutputDirectory(String outputDirectory) {\n    config.setOutputDirectory(outputDirectory);\n  }\n\n  public boolean isGenerateGroupsAttribute() {\n    return config.isGenerateGroupsAttribute();\n  }\n\n  public void setGenerateGroupsAttribute(boolean generateGroupsAttribute) {\n    config.setGenerateGroupsAttribute(generateGroupsAttribute);\n  }\n\n  public boolean isSplitClassAndPackageNames() {\n    return config.isSplitClassAndPackageNames();\n  }\n\n  public void setSplitClassAndPackageNames(boolean splitClassAndPackageNames) {\n    config.setSplitClassAndPackageNames(splitClassAndPackageNames);\n  }\n\n  public String getTimestampFormat() {\n    return config.getTimestampFormat();\n  }\n\n  public void setTimestampFormat(String timestampFormat) {\n    config.setTimestampFormat(timestampFormat);\n  }\n\n  public boolean isGenerateDependsOnMethods() {\n    return config.isGenerateDependsOnMethods();\n  }\n\n  public void setGenerateDependsOnMethods(boolean generateDependsOnMethods) {\n    config.setGenerateDependsOnMethods(generateDependsOnMethods);\n  }\n\n  public void setGenerateDependsOnGroups(boolean generateDependsOnGroups) {\n    config.setGenerateDependsOnGroups(generateDependsOnGroups);\n  }\n\n  public boolean isGenerateDependsOnGroups() {\n    return config.isGenerateDependsOnGroups();\n  }\n\n  public void setGenerateTestResultAttributes(boolean generateTestResultAttributes) {\n    config.setGenerateTestResultAttributes(generateTestResultAttributes);\n  }\n\n  public boolean isGenerateTestResultAttributes() {\n    return config.isGenerateTestResultAttributes();\n  }\n\n}\n"
 ===========================================================================
 testng._22.Driver.setFileFragmentationLevel(int):::ENTER
 this has only one value
@@ -11888,7 +11898,7 @@
 testng._22.requirements.org.testng.reporters.XMLUtils.EOL.toString == orig(testng._22.requirements.org.testng.reporters.XMLUtils.EOL.toString)
 ===========================================================================
 testng._22.requirements.org.testng.reporters.XMLUtils.escape(java.lang.String):::ENTER
-input.toString one of { "0", "2025-12-20T06:54:58 UTC", "TestSuite" }
+input.toString one of { "0", "2025-12-20T06:56:30 UTC", "TestSuite" }
 testng._22.requirements.org.testng.reporters.XMLUtils.EOL.toString < input.toString
 ===========================================================================
 testng._22.requirements.org.testng.reporters.XMLUtils.escape(java.lang.String):::EXIT
@@ -11898,7 +11908,7 @@
 testng._22.requirements.org.testng.reporters.XMLUtils.EOL.toString == orig(testng._22.requirements.org.testng.reporters.XMLUtils.EOL.toString)
 input.toString == return.toString
 input.toString == orig(input.toString)
-input.toString one of { "0", "2025-12-20T06:54:58 UTC", "TestSuite" }
+input.toString one of { "0", "2025-12-20T06:56:30 UTC", "TestSuite" }
 testng._22.requirements.org.testng.reporters.XMLUtils.EOL.toString < input.toString
 ===========================================================================
 testng._22.requirements.org.testng.reporters.XMLUtils.extractComment(java.lang.String, java.util.Properties):::ENTER
