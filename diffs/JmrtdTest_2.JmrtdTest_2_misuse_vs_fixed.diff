--- /dev/fd/63	2025-12-20 07:52:18.789051148 +0000
+++ /dev/fd/62	2025-12-20 07:52:18.788051122 +0000
@@ -24,38 +24,28 @@
 return.open == return.notifyAAPerformed
 return.aaCipherField == return.stateField
 return.targetClassName has only one value
-return.targetClassName.toString == "jmrtd._2.VARIANT.PassportAuthService"
+return.targetClassName.toString == "jmrtd._2.VARIANT.SecureMessagingWrapper"
 return.targetClass has only one value
 return.instance == null
-return.sourceFilePath.toString == "src/main/java/jmrtd/_2/VARIANT/PassportAuthService.java"
+return.sourceFilePath.toString == "src/main/java/jmrtd/_2/VARIANT/SecureMessagingWrapper.java"
 return.open == null
 return.aaCipherField == null
-return.isPassportAuthService == true
+return.isPassportAuthService == false
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases:::OBJECT
-this.getClass().getName() == jmrtd.JmrtdTest_2$Variant.class
-===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.PassportAuthServiceCases():::EXIT
-===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testContainsPassportAuthService():::ENTER
+jmrtd.JmrtdTest_2$Variant.testDoesNotContainPassportAuthService():::ENTER
 this has only one value
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testContainsPassportAuthService():::EXIT
+jmrtd.JmrtdTest_2$Variant.testDoesNotContainPassportAuthService():::EXIT
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testRsaDecryptModeWorks():::ENTER
+jmrtd.JmrtdTest_2$Variant.testNoDoAAMethod():::ENTER
 this has only one value
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testRsaDecryptModeWorks():::EXIT
+jmrtd.JmrtdTest_2$Variant.testNoDoAAMethod():::EXIT
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testRsaEncryptModeProducesDifferentResult():::ENTER
+jmrtd.JmrtdTest_2$Variant.testSourceFileExists():::ENTER
 this has only one value
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testRsaEncryptModeProducesDifferentResult():::EXIT
-===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testSourceFileExists():::ENTER
-this has only one value
-===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testSourceFileExists():::EXIT
+jmrtd.JmrtdTest_2$Variant.testSourceFileExists():::EXIT
 ===========================================================================
 jmrtd._2.Driver:::OBJECT
 this.instance == this.open
@@ -77,26 +67,26 @@
 this.aaCipherField == this.stateField
 this.targetClassName has only one value
 this.targetClassName != null
-this.targetClassName.toString == "jmrtd._2.VARIANT.PassportAuthService"
+this.targetClassName.toString == "jmrtd._2.VARIANT.SecureMessagingWrapper"
 this.targetClass has only one value
 this.targetClass != null
 this.instance == null
 this.sourceFilePath != null
-this.sourceFilePath.toString == "src/main/java/jmrtd/_2/VARIANT/PassportAuthService.java"
+this.sourceFilePath.toString == "src/main/java/jmrtd/_2/VARIANT/SecureMessagingWrapper.java"
 this.open == null
 this.aaCipherField == null
-this.isPassportAuthService == true
+this.isPassportAuthService == false
 this.targetClassName.toString < this.sourceFilePath.toString
 ===========================================================================
 jmrtd._2.Driver.Driver(java.lang.String):::ENTER
 targetClassName has only one value
-targetClassName.toString == "jmrtd._2.VARIANT.PassportAuthService"
+targetClassName.toString == "jmrtd._2.VARIANT.SecureMessagingWrapper"
 ===========================================================================
 jmrtd._2.Driver.Driver(java.lang.String):::EXIT
 this.targetClassName == orig(targetClassName)
 this.targetClassName.toString == targetClassName.toString
 targetClassName.toString == orig(targetClassName.toString)
-targetClassName.toString == "jmrtd._2.VARIANT.PassportAuthService"
+targetClassName.toString == "jmrtd._2.VARIANT.SecureMessagingWrapper"
 ===========================================================================
 jmrtd._2.Driver.containsPassportAuthService():::ENTER
 this has only one value
@@ -129,79 +119,9 @@
 this.isPassportAuthService == return
 return == orig(this.isPassportAuthService)
 this.sourceFilePath has only one value
-return == true
-===========================================================================
-jmrtd._2.Driver.containsPassportAuthService():::EXIT;condition="return == true"
-===========================================================================
-jmrtd._2.Driver.findMethodEnd(java.lang.String, int):::ENTER
-sourceCode.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
-methodStart == 1934
-===========================================================================
-jmrtd._2.Driver.findMethodEnd(java.lang.String, int):::EXIT
-===========================================================================
-jmrtd._2.Driver.findMethodEnd(java.lang.String, int):::EXIT
-this.targetClassName == orig(this.targetClassName)
-this.targetClassName.toString == orig(this.targetClassName.toString)
-this.targetClass == orig(this.targetClass)
-this.instance == orig(this.instance)
-this.sourceFilePath == orig(this.sourceFilePath)
-this.sourceFilePath.toString == orig(this.sourceFilePath.toString)
-this.open == orig(this.open)
-this.open == orig(this.openWithId)
-this.open == orig(this.getTerminals)
-this.open == orig(this.doBAC)
-this.open == orig(this.addAuthenticationListener)
-this.open == orig(this.removeAuthenticationListener)
-this.open == orig(this.doAA)
-this.open == orig(this.sendAPDU)
-this.open == orig(this.close)
-this.open == orig(this.addAPDUListener)
-this.open == orig(this.removeAPDUListener)
-this.open == orig(this.getWrapper)
-this.open == orig(this.setWrapper)
-this.open == orig(this.notifyBACPerformed)
-this.open == orig(this.notifyAAPerformed)
-this.aaCipherField == orig(this.aaCipherField)
-this.aaCipherField == orig(this.stateField)
-this.isPassportAuthService == orig(this.isPassportAuthService)
-sourceCode.toString == orig(sourceCode.toString)
-sourceCode.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
-return == 9215
-===========================================================================
-jmrtd._2.Driver.getCipherModeFromSource():::ENTER
-this has only one value
-this.sourceFilePath has only one value
+return == false
 ===========================================================================
-jmrtd._2.Driver.getCipherModeFromSource():::EXIT
-===========================================================================
-jmrtd._2.Driver.getCipherModeFromSource():::EXIT
-this.targetClassName == orig(this.targetClassName)
-this.targetClassName.toString == orig(this.targetClassName.toString)
-this.targetClass == orig(this.targetClass)
-this.instance == orig(this.instance)
-this.sourceFilePath == orig(this.sourceFilePath)
-this.sourceFilePath.toString == orig(this.sourceFilePath.toString)
-this.open == orig(this.open)
-this.open == orig(this.openWithId)
-this.open == orig(this.getTerminals)
-this.open == orig(this.doBAC)
-this.open == orig(this.addAuthenticationListener)
-this.open == orig(this.removeAuthenticationListener)
-this.open == orig(this.doAA)
-this.open == orig(this.sendAPDU)
-this.open == orig(this.close)
-this.open == orig(this.addAPDUListener)
-this.open == orig(this.removeAPDUListener)
-this.open == orig(this.getWrapper)
-this.open == orig(this.setWrapper)
-this.open == orig(this.notifyBACPerformed)
-this.open == orig(this.notifyAAPerformed)
-this.aaCipherField == orig(this.aaCipherField)
-this.aaCipherField == orig(this.stateField)
-this.isPassportAuthService == orig(this.isPassportAuthService)
-this.sourceFilePath has only one value
-return has only one value
-return.toString == "ENCRYPT_MODE"
+jmrtd._2.Driver.containsPassportAuthService():::EXIT;condition="not(return == true)"
 ===========================================================================
 jmrtd._2.Driver.readSourceCode():::ENTER
 ===========================================================================
@@ -230,7 +150,7 @@
 this.aaCipherField == orig(this.aaCipherField)
 this.aaCipherField == orig(this.stateField)
 this.isPassportAuthService == orig(this.isPassportAuthService)
-return.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
+return.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.util.Arrays;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.Mac;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.IvParameterSpec;\n\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.ISO7816;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.Util;\n\n/**\n * Secure messaging wrapper for apdus.\n * Based on Section E.3 of ICAO-TR-PKI.\n *\n * @author Cees-Bart Breunesse (ceesb@cs.ru.nl)\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class SecureMessagingWrapper implements Apdu.Wrapper\n{\n   private static final IvParameterSpec ZERO_IV_PARAM_SPEC =\n      new IvParameterSpec(new byte[8]);\n\n   private SecretKey ksEnc, ksMac;\n   private Cipher cipher;\n   private Mac mac;\n   private long ssc;\n\n   /**\n    * Constructs a secure messaging wrapper based on the secure messaging\n    * session keys. The initial value of the send sequence counter is set\n    * to <code>0L</code>.\n    *\n    * @param ksEnc the session key for encryption\n    * @param ksMac the session key for macs\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives\n    *         (\"DESede/CBC/Nopadding\" Cipher, \"ISO9797Alg3Mac\" Mac).\n    */\n   public SecureMessagingWrapper(SecretKey ksEnc, SecretKey ksMac)\n   throws GeneralSecurityException {\n      this(ksEnc, ksMac, 0L);\n   }\n\n   /**\n    * Constructs a secure messaging wrapper based on the secure messaging\n    * session keys and the initial value of the send sequence counter.\n    *\n    * @param ksEnc the session key for encryption\n    * @param ksMac the session key for macs\n    * @param ssc the initial value of the send sequence counter\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives\n    *         (\"DESede/CBC/Nopadding\" Cipher, \"ISO9797Alg3Mac\" Mac).\n    */\n   public SecureMessagingWrapper(SecretKey ksEnc, SecretKey ksMac, long ssc)\n   throws GeneralSecurityException {\n      this.ksEnc = ksEnc;\n      this.ksMac = ksMac;\n      this.ssc = ssc;\n      cipher = Cipher.getInstance(\"DESede/CBC/NoPadding\");\n      mac = Mac.getInstance(\"ISO9797Alg3Mac\");\n   }\n\n   /**\n    * Gets the current value of the send sequence counter.\n    *\n    * @return the current value of the send sequence counter.\n    */\n   public /*@ pure */ long getSendSequenceCounter() {\n      return ssc;\n   }\n\n   /**\n    * Wraps the apdu buffer <code>capdu</code> of a command apdu.\n    * As a side effect, this method increments the internal send\n    * sequence counter maintained by this wrapper.\n    *\n    * @param capdu buffer containing the command apdu.\n    *\n    * @return length of the command apdu after wrapping.\n    */\n   public byte[] wrap(byte[] capdu) {\n      try {\n         byte[] wrappedApdu = wrapCommandAPDU(capdu, capdu.length);\n         // System.arraycopy(wrappedApdu, 0, capdu, 0, wrappedApdu.length);\n         return wrappedApdu;\n      } catch (GeneralSecurityException gse) {\n         gse.printStackTrace();\n         throw new IllegalStateException(gse.toString());\n      } catch (IOException ioe) {\n         ioe.printStackTrace();\n         throw new IllegalStateException(ioe.toString());\n      }\n   }\n\n   /**\n    * Unwraps the apdu buffer <code>rapdu</code> of a response apdu.\n    *\n    * @param rapdu buffer containing the response apdu.\n    * @param len length of the actual response apdu.\n    *\n    * @return a new byte array containing the unwrapped buffer.\n    */\n   public byte[] unwrap(byte[] rapdu, int len) {\n      try {\n         return unwrapResponseAPDU(rapdu, len);\n      } catch (GeneralSecurityException gse) {\n         gse.printStackTrace();\n         throw new IllegalStateException(gse.toString());\n      } catch (IOException ioe) {\n         ioe.printStackTrace();\n         throw new IllegalStateException(ioe.toString());\n      }\n   }\n\n   /**\n    * Does the actual encoding of a command apdu.\n    * Based on Section E.3 of ICAO-TR-PKI, especially the examples.\n    *\n    * @param capdu buffer containing the apdu data. It must be large enough\n    *             to receive the wrapped apdu.\n    * @param len length of the apdu data.\n    *\n    * @return a byte array containing the wrapped apdu buffer.\n    */\n   /*@ requires apdu != null && 4 <= len && len <= apdu.length;\n    */\n   private byte[] wrapCommandAPDU(byte[] capdu, int len\n   ) throws GeneralSecurityException, IOException {\n      if (capdu == null || capdu.length < 4 || len < 4) {\n         throw new IllegalArgumentException(\"Invalid type\");\n      }\n\n      /* Determine lc and le... */\n      int lc = 0;\n      int le = capdu[len - 1] & 0x000000FF;\n      if (len == 4) {\n         lc = 0;\n         le = 0;\n      } else if (len == 5) {\n         /* No command data, byte at index 5 is le. */\n         lc = 0;\n      } else if (len > 5) {\n         /* Byte at index 5 is not le, so it must be lc. */\n         lc = capdu[ISO7816.OFFSET_LC] & 0x000000FF;\n      }\n      if (4 + lc >= len) {\n         /* Value of lc covers rest of apdu length, there is no le. */\n         le = 0;\n      }\n\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n\n      byte[] maskedHeader = new byte[4];\n      System.arraycopy(capdu, 0, maskedHeader, 0, 4);\n      maskedHeader[ISO7816.OFFSET_CLA] = (byte)0x0C;\n      byte[] paddedHeader = Util.pad(maskedHeader);\n\n      byte[] do87 = new byte[0];\n      byte[] do8E = new byte[0];\n      byte[] do97 = new byte[0];\n\n      if (le > 0) {\n         out.reset();\n         out.write((byte)0x97);\n         out.write((byte)0x01);\n         out.write((byte)le);\n         do97 = out.toByteArray();\n      }\n\n      if (lc > 0) {\n         byte[] data = Util.pad(capdu, ISO7816.OFFSET_CDATA, lc);\n         cipher.init(Cipher.ENCRYPT_MODE, ksEnc, ZERO_IV_PARAM_SPEC);\n         byte[] ciphertext = cipher.doFinal(data);\n\n         out.reset();\n         out.write((byte)0x87);\n         out.write((byte)(ciphertext.length + 1));\n         out.write(0x01);\n         out.write(ciphertext, 0, ciphertext.length);\n         do87 = out.toByteArray();\n      }\n\n      out.reset();\n      out.write(paddedHeader, 0, paddedHeader.length);\n      out.write(do87, 0, do87.length);\n      out.write(do97, 0, do97.length);\n      byte[] m = out.toByteArray();\n\n      out.reset();\n      DataOutputStream dataOut = new DataOutputStream(out);\n      ssc++;\n      dataOut.writeLong(ssc);\n      dataOut.write(m, 0, m.length);\n      dataOut.flush();\n      byte[] n = Util.pad(out.toByteArray());\n\n      /* Compute cryptographic checksum... */\n      mac.init(ksMac);\n      byte[] cc = mac.doFinal(n);\n      // ssc++; // TODO dit snappen\n\n      out.reset();\n      out.write((byte)0x8E);\n      out.write(cc.length);\n      out.write(cc, 0, cc.length);\n      do8E = out.toByteArray();\n\n      /* Construct protected apdu... */\n      out.reset();\n      out.write(maskedHeader, 0, 4);\n      out.write((byte)(do87.length + do97.length + do8E.length));\n      out.write(do87, 0, do87.length);\n      out.write(do97, 0, do97.length);\n      out.write(do8E, 0, do8E.length);\n      out.write(0x00);\n\n      return out.toByteArray();\n   }\n\n   /**\n    * Does the actual decoding of a response apdu.\n    * Based on Section E.3 of TR-PKI, especially the examples.\n    *\n    * @param rapdu buffer containing the apdu data.\n    * @param len length of the apdu data.\n    *\n    * @return a byte array containing the unwrapped apdu buffer.\n    */\n   private byte[] unwrapResponseAPDU(byte[] rapdu, int len\n   ) throws GeneralSecurityException, IOException {\n      if (rapdu == null || rapdu.length < 2 || len < 2) {\n         throw new IllegalArgumentException(\"Invalid type\");\n      }\n      cipher.init(Cipher.DECRYPT_MODE, ksEnc, ZERO_IV_PARAM_SPEC);\n      DataInputStream in = new DataInputStream(new ByteArrayInputStream(rapdu));\n      byte[] data = new byte[0];\n      short sw = 0;\n      boolean finished = false;\n      while (!finished) {\n         int tag = in.readByte();\n         switch (tag) {\n            case (byte)0x87: data = readDO87(in); break;\n            case (byte)0x99: sw = readDO99(in); break;\n            case (byte)0x8E: readDO8E(in, rapdu); finished = true; break;\n         }\n      }\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n      out.write(data, 0, data.length);\n      out.write((sw & 0x0000FF00) >> 8);\n      out.write(sw & 0x000000FF);\n      return out.toByteArray();\n   }\n\n   /**\n    * The <code>0x87</code> tag has already been read.\n    *\n    * @param in inputstream to read from.\n    */\n   private byte[] readDO87(DataInputStream in\n   ) throws IOException, GeneralSecurityException {\n      /* Read length... */\n      int length = 0;\n      int buf = in.readUnsignedByte();\n      if ((buf & 0x00000080) != 0x00000080) {\n         /* Short form */\n         length = buf;\n         buf = in.readUnsignedByte(); /* should be 0x01... */\n         if (buf != 0x01) {\n            throw new IllegalStateException(\"DO'87 expected 0x01 marker \"\n                + Integer.toHexString(buf));\n         }\n      } else {\n         /* Long form */\n         int lengthBytesCount = buf & 0x0000007F;\n         for (int i = 0; i < lengthBytesCount; i++) {\n            length = (length << 8) | in.readUnsignedByte();\n         }\n         buf = in.readUnsignedByte(); /* should be 0x01... */\n         if (buf != 0x01) {\n            throw new IllegalStateException(\"DO'87 expected 0x01 marker\");\n         }\n      }\n      length--; /* takes care of the extra 0x01 marker... */\n      \n      /* Read, decrypt, unpad the data... */\n      byte[] ciphertext = new byte[length];\n      in.read(ciphertext, 0, length);\n      byte[] paddedData = cipher.doFinal(ciphertext);\n      // System.out.println(\"DEBUG: paddedData = \" + Hex.bytesToHexString(paddedData));\n      byte[] data = Util.unpad(paddedData);\n      return data;\n   }\n\n   /**\n    * The <code>0x99</code> tag has already been read.\n    *\n    * @param in inputstream to read from.\n    */\n   private short readDO99(DataInputStream in) throws IOException {\n      int length = in.readUnsignedByte();\n      if (length != 2) {\n         throw new IllegalStateException(\"DO'99 wrong length\");\n      }\n      byte sw1 = in.readByte();\n      byte sw2 = in.readByte();\n      return (short)(((sw1 & 0x000000FF) << 8) | (sw2 & 0x000000FF));\n   }\n\n   /**\n    * The <code>0x8E</code> tag has already been read.\n    *\n    * @param in inputstream to read from.\n    */\n   private void readDO8E(DataInputStream in, byte[] rapdu\n   ) throws IOException, GeneralSecurityException {\n      int length = in.readUnsignedByte();\n      if (length != 8) {\n         throw new IllegalStateException(\"DO'8E wrong length\");\n      }\n      byte[] cc1 = new byte[8];\n      in.readFully(cc1);\n      mac.init(ksMac);\n      ByteArrayOutputStream out = new ByteArrayOutputStream();\n      DataOutputStream dataOut = new DataOutputStream(out);\n      try {\n         ssc++;\n         dataOut.writeLong(ssc);\n         byte[] paddedData = Util.pad(rapdu, 0, rapdu.length - 2 - 8 - 2);\n         dataOut.write(paddedData, 0, paddedData.length);\n         dataOut.flush();\n      } finally {\n         dataOut.close();\n      }\n      byte[] cc2 = mac.doFinal(out.toByteArray());\n      if (!Arrays.equals(cc1, cc2)) {\n         throw new IllegalStateException(\"Incorrect MAC!\");\n      }\n   }\n}\n"
 ===========================================================================
 jmrtd._2.Driver.usesDecryptMode():::ENTER
 this has only one value
@@ -264,47 +184,9 @@
 this.open == orig(this.notifyAAPerformed)
 this.aaCipherField == orig(this.aaCipherField)
 this.aaCipherField == orig(this.stateField)
-this.isPassportAuthService == orig(this.isPassportAuthService)
-this.sourceFilePath has only one value
-return == false
-===========================================================================
-jmrtd._2.Driver.usesDecryptMode():::EXIT;condition="not(return == true)"
-===========================================================================
-jmrtd._2.Driver.usesEncryptMode():::ENTER
-this has only one value
-this.sourceFilePath has only one value
-===========================================================================
-jmrtd._2.Driver.usesEncryptMode():::EXIT
-===========================================================================
-jmrtd._2.Driver.usesEncryptMode():::EXIT;condition="return == true"
-===========================================================================
-jmrtd._2.Driver.usesEncryptMode():::EXIT
-this.targetClassName == orig(this.targetClassName)
-this.targetClassName.toString == orig(this.targetClassName.toString)
-this.targetClass == orig(this.targetClass)
-this.instance == orig(this.instance)
-this.sourceFilePath == orig(this.sourceFilePath)
-this.sourceFilePath.toString == orig(this.sourceFilePath.toString)
-this.open == orig(this.open)
-this.open == orig(this.openWithId)
-this.open == orig(this.getTerminals)
-this.open == orig(this.doBAC)
-this.open == orig(this.addAuthenticationListener)
-this.open == orig(this.removeAuthenticationListener)
-this.open == orig(this.doAA)
-this.open == orig(this.sendAPDU)
-this.open == orig(this.close)
-this.open == orig(this.addAPDUListener)
-this.open == orig(this.removeAPDUListener)
-this.open == orig(this.getWrapper)
-this.open == orig(this.setWrapper)
-this.open == orig(this.notifyBACPerformed)
-this.open == orig(this.notifyAAPerformed)
-this.aaCipherField == orig(this.aaCipherField)
-this.aaCipherField == orig(this.stateField)
 this.isPassportAuthService == return
 return == orig(this.isPassportAuthService)
 this.sourceFilePath has only one value
-return == true
+return == false
 ===========================================================================
-jmrtd._2.Driver.usesEncryptMode():::EXIT;condition="return == true"
+jmrtd._2.Driver.usesDecryptMode():::EXIT;condition="not(return == true)"
