--- /dev/fd/63	2025-12-20 07:52:18.869053257 +0000
+++ /dev/fd/62	2025-12-20 07:52:18.869053257 +0000
@@ -4,6 +4,11 @@
 ===========================================================================
 rhino.RhinoTest_1$CommonCases.CommonCases():::EXIT
 ===========================================================================
+rhino.RhinoTest_1$CommonCases.testInitFunctionCalledOnce():::ENTER
+this has only one value
+===========================================================================
+rhino.RhinoTest_1$CommonCases.testInitFunctionCalledOnce():::EXIT
+===========================================================================
 rhino.RhinoTest_1$CommonCases.testParseDeeplyNestedFunctions():::ENTER
 this has only one value
 ===========================================================================
@@ -35,8 +40,8 @@
 return.parserClass has only one value
 return.variant has only one value
 return.variant.toString == "VARIANT"
-return.sourceCode.toString == "/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n *\n * The contents of this file are subject to the Netscape Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/NPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Variant Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Variant Code is Netscape\n * Communications Corporation.  Portions created by Netscape are\n * Copyright (C) 1997-1999 Netscape Communications Corporation. All\n * Rights Reserved.\n *\n * Contributor(s):\n * Mike Ang\n * Igor Bukanov\n * Ethan Hugg\n * Terry Lucas\n * Mike McCabe\n * Milen Nankov\n *\n * Alternatively, the contents of this file may be used under the\n * terms of the GNU Public License (the \"GPL\"), in which case the\n * provisions of the GPL are applicable instead of those above.\n * If you wish to allow use of your version of this file only\n * under the terms of the GPL and not to allow others to use your\n * version of this file under the NPL, indicate your decision by\n * deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL.  If you do not delete\n * the provisions above, a recipient may use your version of this\n * file under either the NPL or the GPL.\n */\n\npackage rhino._1.VARIANT;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\nimport rhino._1.mocks.*;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\n\npublic class Parser\n{\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int\n        CLEAR_TI_MASK  = 0xFFFF,   // mask to clear token information bits\n        TI_AFTER_EOL   = 1 << 16,  // first token of the source line\n        TI_CHECK_LABEL = 1 << 17;  // indicates to check for label\n\n    CompilerEnvirons compilerEnv;\n    private ErrorReporter errorReporter;\n    private String sourceURI;\n\n    private TokenStream ts;\n    private int currentFlaggedToken;\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n    private String encodedSource;\n\n// The following are per function variables and should be saved/restored\n// during function parsing.\n// XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n    private int nestingOfWith;\n    private Hashtable labelSet; // map of label names into nodes\n    private ObjArray loopSet;\n    private ObjArray loopAndSwitchSet;\n// end of per function variables\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException\n    {\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter)\n    {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv)\n    {\n        return new Decompiler();\n    }\n\n    void addWarning(String messageId, String messageArg)\n    {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.warning(message, sourceURI, ts.getLineno(),\n                              ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId)\n    {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(),\n                            ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId)\n    {\n        addError(messageId);\n\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken()\n        throws IOException\n    {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken()\n    {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken()\n        throws IOException\n    {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch)\n        throws IOException\n    {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL()\n        throws IOException\n    {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel()\n    {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId)\n        throws IOException, ParserException\n    {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML()\n    {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource()\n    {\n        return encodedSource;\n    }\n\n    public boolean eof()\n    {\n        return ts.eof();\n    }\n\n    boolean insideFunction()\n    {\n        return nestingOfFunction != 0;\n    }\n\n    private Node enterLoop(Node loopLabel)\n    {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        return loop;\n    }\n\n    private void exitLoop()\n    {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel)\n    {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch()\n    {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString,\n                                String sourceURI, int lineno)\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader,\n                                String sourceURI, int lineno)\n        throws IOException\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse()\n        throws IOException\n    {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n\n        try {\n            for (;;) {\n                int tt = peekToken();\n\n                if (tt <= Token.EOF) {\n                    break;\n                }\n\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\n                \"mag.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI,\n                                             ts.getLineno(), null, 0);\n        }\n\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno,\n                                             null, 0);\n        }\n\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset,\n                                                 sourceEndOffset);\n\n        nf.initScript(currentScriptOrFn, pn);\n\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        this.decompiler = null; // It helps GC\n\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody()\n        throws IOException\n    {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (;;) {\n                Node n;\n                int tt = peekToken();\n                switch (tt) {\n                  case Token.ERROR:\n                  case Token.EOF:\n                  case Token.RC:\n                    break bodyLoop;\n\n                  case Token.FUNCTION:\n                    consumeToken();\n                    n = function(FunctionNode.FUNCTION_STATEMENT);\n                    break;\n                  default:\n                    n = statement();\n                    break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n\n        return pn;\n    }\n\n    private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements()\n        throws IOException\n    {\n        Node pn = nf.createBlock(ts.getLineno());\n\n        int tt;\n        while((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n\n        return pn;\n    }\n\n    private Node condition()\n        throws IOException, ParserException\n    {\n        Node pn;\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n\n        // there's a check here in jsparse.c that corrects = to ==\n\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName()\n        throws IOException, ParserException\n    {\n        Node label = null;\n\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = (Node)labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n\n        return label;\n    }\n\n    private Node statement()\n        throws IOException\n    {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                return pn;\n            }\n        } catch (ParserException e) { }\n\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (;;) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch (tt) {\n              case Token.ERROR:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.SEMI:\n                break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    /**\n     * Whether the \"catch (e: e instanceof Exception) { ... }\" syntax\n     * is implemented.\n     */\n\n    private Node statementHelper(Node statementLabel)\n        throws IOException, ParserException\n    {\n        Node pn = null;\n\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n          case Token.IF: {\n            consumeToken();\n\n            decompiler.addToken(Token.IF);\n            int lineno = ts.getLineno();\n            Node cond = condition();\n            decompiler.addEOL(Token.LC);\n            Node ifTrue = statement();\n            Node ifFalse = null;\n            if (matchToken(Token.ELSE)) {\n                decompiler.addToken(Token.RC);\n                decompiler.addToken(Token.ELSE);\n                decompiler.addEOL(Token.LC);\n                ifFalse = statement();\n            }\n            decompiler.addEOL(Token.RC);\n            pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n            return pn;\n          }\n\n          case Token.SWITCH: {\n            consumeToken();\n\n            decompiler.addToken(Token.SWITCH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n            decompiler.addToken(Token.LP);\n            pn = enterSwitch(expr(false), lineno, statementLabel);\n            try {\n                mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                decompiler.addEOL(Token.LC);\n\n                boolean hasDefault = false;\n                switchLoop: for (;;) {\n                    tt = nextToken();\n                    Node caseExpression;\n                    switch (tt) {\n                      case Token.RC:\n                        break switchLoop;\n\n                      case Token.CASE:\n                        decompiler.addToken(Token.CASE);\n                        caseExpression = expr(false);\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      case Token.DEFAULT:\n                        if (hasDefault) {\n                            reportError(\"msg.double.switch.default\");\n                        }\n                        decompiler.addToken(Token.DEFAULT);\n                        hasDefault = true;\n                        caseExpression = null;\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      default:\n                        reportError(\"msg.bad.switch\");\n                        break switchLoop;\n                    }\n\n                    Node block = nf.createLeaf(Token.BLOCK);\n                    while ((tt = peekToken()) != Token.RC\n                           && tt != Token.CASE\n                           && tt != Token.DEFAULT\n                           && tt != Token.EOF)\n                    {\n                        nf.addChildToBack(block, statement());\n                    }\n\n                    // caseExpression == null => add default lable\n                    nf.addSwitchCase(pn, caseExpression, block);\n                }\n                decompiler.addEOL(Token.RC);\n                nf.closeSwitch(pn);\n            } finally {\n                exitSwitch();\n            }\n            return pn;\n          }\n\n          case Token.WHILE: {\n            consumeToken();\n            decompiler.addToken(Token.WHILE);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node cond = condition();\n                decompiler.addEOL(Token.LC);\n                Node body = statement();\n                decompiler.addEOL(Token.RC);\n                pn = nf.createWhile(loop, cond, body);\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.DO: {\n            consumeToken();\n            decompiler.addToken(Token.DO);\n            decompiler.addEOL(Token.LC);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node body = statement();\n                decompiler.addToken(Token.RC);\n                mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                decompiler.addToken(Token.WHILE);\n                Node cond = condition();\n                pn = nf.createDoWhile(loop, body, cond);\n            } finally {\n                exitLoop();\n            }\n            // Always auto-insert semicon to follow SpiderMonkey:\n            // It is required by EMAScript but is ignored by the rest of\n            // world, see bug 238945\n            matchToken(Token.SEMI);\n            decompiler.addEOL(Token.SEMI);\n            return pn;\n          }\n\n          case Token.FOR: {\n            consumeToken();\n            boolean isForEach = false;\n            decompiler.addToken(Token.FOR);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n\n                Node init;  // Node init is also foo in 'foo in Object'\n                Node cond;  // Node cond is also object in 'foo in Object'\n                Node incr = null; // to kill warning\n                Node body;\n\n                // See if this is a for each () instead of just a for ()\n                if (matchToken(Token.NAME)) {\n                    decompiler.addName(ts.getString());\n                    if (ts.getString().equals(\"each\")) {\n                        isForEach = true;\n                    } else {\n                        reportError(\"msg.no.paren.for\");\n                    }\n                }\n\n                mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                decompiler.addToken(Token.LP);\n                tt = peekToken();\n                if (tt == Token.SEMI) {\n                    init = nf.createLeaf(Token.EMPTY);\n                } else {\n                    if (tt == Token.VAR) {\n                        // set init to a var list or initial\n                        consumeToken();    // consume the 'var' token\n                        init = variables(true);\n                    }\n                    else {\n                        init = expr(true);\n                    }\n                }\n\n                if (matchToken(Token.IN)) {\n                    decompiler.addToken(Token.IN);\n                    // 'cond' is the object over which we're iterating\n                    cond = expr(false);\n                } else {  // ordinary for loop\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.SEMI) {\n                        // no loop condition\n                        cond = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        cond = expr(false);\n                    }\n\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.RP) {\n                        incr = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        incr = expr(false);\n                    }\n                }\n\n                mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                decompiler.addToken(Token.RP);\n                decompiler.addEOL(Token.LC);\n                body = statement();\n                decompiler.addEOL(Token.RC);\n\n                if (incr == null) {\n                    // cond could be null if 'in obj' got eaten\n                    // by the init node.\n                    pn = nf.createForIn(loop, init, cond, body, isForEach);\n                } else {\n                    pn = nf.createFor(loop, init, cond, incr, body);\n                }\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.TRY: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            Node tryblock;\n            Node catchblocks = null;\n            Node finallyblock = null;\n\n            decompiler.addToken(Token.TRY);\n            decompiler.addEOL(Token.LC);\n            tryblock = statement();\n            decompiler.addEOL(Token.RC);\n\n            catchblocks = nf.createLeaf(Token.BLOCK);\n\n            boolean sawDefaultCatch = false;\n            int peek = peekToken();\n            if (peek == Token.CATCH) {\n                while (matchToken(Token.CATCH)) {\n                    if (sawDefaultCatch) {\n                        reportError(\"msg.catch.unreachable\");\n                    }\n                    decompiler.addToken(Token.CATCH);\n                    mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                    decompiler.addToken(Token.LP);\n\n                    mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                    String varName = ts.getString();\n                    decompiler.addName(varName);\n\n                    Node catchCond = null;\n                    if (matchToken(Token.IF)) {\n                        decompiler.addToken(Token.IF);\n                        catchCond = expr(false);\n                    } else {\n                        sawDefaultCatch = true;\n                    }\n\n                    mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                    decompiler.addToken(Token.RP);\n                    mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                    decompiler.addEOL(Token.LC);\n\n                    nf.addChildToBack(catchblocks,\n                        nf.createCatch(varName, catchCond,\n                                       statements(),\n                                       ts.getLineno()));\n\n                    mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                    decompiler.addEOL(Token.RC);\n                }\n            } else if (peek != Token.FINALLY) {\n                mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n            }\n\n            if (matchToken(Token.FINALLY)) {\n                decompiler.addToken(Token.FINALLY);\n                decompiler.addEOL(Token.LC);\n                finallyblock = statement();\n                decompiler.addEOL(Token.RC);\n            }\n\n            pn = nf.createTryCatchFinally(tryblock, catchblocks,\n                                          finallyblock, lineno);\n\n            return pn;\n          }\n\n          case Token.THROW: {\n            consumeToken();\n            if (peekTokenOrEOL() == Token.EOL) {\n                // ECMAScript does not allow new lines before throw expression,\n                // see bug 256617\n                reportError(\"msg.bad.throw.eol\");\n            }\n\n            int lineno = ts.getLineno();\n            decompiler.addToken(Token.THROW);\n            pn = nf.createThrow(expr(false), lineno);\n            break;\n          }\n\n          case Token.BREAK: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.BREAK);\n\n            // matchJumpLabelName only matches if there is one\n            Node breakStatement = matchJumpLabelName();\n            if (breakStatement == null) {\n                if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                    reportError(\"msg.bad.break\");\n                    return null;\n                }\n                breakStatement = (Node)loopAndSwitchSet.peek();\n            }\n            pn = nf.createBreak(breakStatement, lineno);\n            break;\n          }\n\n          case Token.CONTINUE: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.CONTINUE);\n\n            Node loop;\n            // matchJumpLabelName only matches if there is one\n            Node label = matchJumpLabelName();\n            if (label == null) {\n                if (loopSet == null || loopSet.size() == 0) {\n                    reportError(\"msg.continue.outside\");\n                    return null;\n                }\n                loop = (Node)loopSet.peek();\n            } else {\n                loop = nf.getLabelLoop(label);\n                if (loop == null) {\n                    reportError(\"msg.continue.nonloop\");\n                    return null;\n                }\n            }\n            pn = nf.createContinue(loop, lineno);\n            break;\n          }\n\n          case Token.WITH: {\n            consumeToken();\n\n            decompiler.addToken(Token.WITH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.with\");\n            decompiler.addToken(Token.LP);\n            Node obj = expr(false);\n            mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n            decompiler.addToken(Token.RP);\n            decompiler.addEOL(Token.LC);\n\n            ++nestingOfWith;\n            Node body;\n            try {\n                body = statement();\n            } finally {\n                --nestingOfWith;\n            }\n\n            decompiler.addEOL(Token.RC);\n\n            pn = nf.createWith(obj, body, lineno);\n            return pn;\n          }\n\n          case Token.VAR: {\n            consumeToken();\n            pn = variables(false);\n            break;\n          }\n\n          case Token.RETURN: {\n            if (!insideFunction()) {\n                reportError(\"msg.bad.return\");\n            }\n            consumeToken();\n            decompiler.addToken(Token.RETURN);\n            int lineno = ts.getLineno();\n\n            Node retExpr;\n            /* This is ugly, but we don't want to require a semicolon. */\n            tt = peekTokenOrEOL();\n            switch (tt) {\n              case Token.SEMI:\n              case Token.RC:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.ERROR:\n                retExpr = null;\n                break;\n              default:\n                retExpr = expr(false);\n            }\n            pn = nf.createReturn(retExpr, lineno);\n            break;\n          }\n\n          case Token.LC:\n            consumeToken();\n            if (statementLabel != null) {\n                decompiler.addToken(Token.LC);\n            }\n            pn = statements();\n            mustMatchToken(Token.RC, \"msg.no.brace.block\");\n            if (statementLabel != null) {\n                decompiler.addEOL(Token.RC);\n            }\n            return pn;\n\n          case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n          case Token.SEMI:\n            consumeToken();\n            pn = nf.createLeaf(Token.EMPTY);\n            return pn;\n\n          case Token.FUNCTION: {\n            consumeToken();\n            pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n            return pn;\n          }\n\n          case Token.DEFAULT :\n            consumeToken();\n            mustHaveXML();\n\n            decompiler.addToken(Token.DEFAULT);\n            int nsLine = ts.getLineno();\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"xml\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"namespace\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!matchToken(Token.ASSIGN)) {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addToken(Token.ASSIGN);\n\n            Node expr = expr(false);\n            pn = nf.createDefaultNamespace(expr, nsLine);\n            break;\n\n          case Token.NAME: {\n            int lineno = ts.getLineno();\n            String name = ts.getString();\n            setCheckForLabel();\n            pn = expr(false);\n            if (pn.getType() != Token.LABEL) {\n                pn = nf.createExprStatement(pn, lineno);\n            } else {\n                // Parsed the label: push back token should be\n                // colon that primaryExpr left untouched.\n                if (peekToken() != Token.COLON) Kit.codeBug();\n                consumeToken();\n                // depend on decompiling lookahead to guess that that\n                // last name was a label.\n                decompiler.addName(name);\n                decompiler.addEOL(Token.COLON);\n\n                if (labelSet == null) {\n                    labelSet = new Hashtable();\n                } else if (labelSet.containsKey(name)) {\n                    reportError(\"msg.dup.label\");\n                }\n\n                boolean firstLabel;\n                if (statementLabel == null) {\n                    firstLabel = true;\n                    statementLabel = pn;\n                } else {\n                    // Discard multiple label nodes and use only\n                    // the first: it allows to simplify IRFactory\n                    firstLabel = false;\n                }\n                labelSet.put(name, statementLabel);\n                try {\n                    pn = statementHelper(statementLabel);\n                } finally {\n                    labelSet.remove(name);\n                }\n                if (firstLabel) {\n                    pn = nf.createLabeledStatement(statementLabel, pn);\n                }\n                return pn;\n            }\n            break;\n          }\n\n          default: {\n            int lineno = ts.getLineno();\n            pn = expr(false);\n            pn = nf.createExprStatement(pn, lineno);\n            break;\n          }\n        }\n\n        int ttFlagged = peekFlaggedToken();\n        switch (ttFlagged & CLEAR_TI_MASK) {\n          case Token.SEMI:\n            // Consume ';' as a part of expression\n            consumeToken();\n            break;\n          case Token.ERROR:\n          case Token.EOF:\n          case Token.RC:\n            // Autoinsert ;\n            break;\n          default:\n            if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                // Report error if no EOL or autoinsert ; otherwise\n                reportError(\"msg.no.semi.stmt\");\n            }\n            break;\n        }\n        decompiler.addEOL(Token.SEMI);\n\n        return pn;\n    }\n\n    private Node variables(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = nf.createVariables(ts.getLineno());\n        boolean first = true;\n\n        decompiler.addToken(Token.VAR);\n\n        for (;;) {\n            Node name;\n            Node init;\n            mustMatchToken(Token.NAME, \"msg.bad.var\");\n            String s = ts.getString();\n\n            if (!first)\n                decompiler.addToken(Token.COMMA);\n            first = false;\n\n            decompiler.addName(s);\n            currentScriptOrFn.addVar(s);\n            name = nf.createName(s);\n\n            // omitted check for argument hiding\n\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n\n                init = assignExpr(inForInit);\n                nf.addChildToBack(name, init);\n            }\n            nf.addChildToBack(pn, name);\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return pn;\n    }\n\n    private Node expr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = condExpr(inForInit);\n\n        int tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node ifTrue;\n        Node ifFalse;\n\n        Node pn = orExpr(inForInit);\n\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = relExpr(inForInit);\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.EQ:\n              case Token.NE:\n              case Token.SHEQ:\n              case Token.SHNE:\n                consumeToken();\n                int decompilerToken = tt;\n                int parseToken = tt;\n                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                    // JavaScript 1.2 uses shallow equality for == and != .\n                    // In addition, convert === and !== for decompiler into\n                    // == and != since the decompiler is supposed to show\n                    // canonical source and in 1.2 ===, !== are allowed\n                    // only as an alias to ==, !=.\n                    switch (tt) {\n                      case Token.EQ:\n                        parseToken = Token.SHEQ;\n                        break;\n                      case Token.NE:\n                        parseToken = Token.SHNE;\n                        break;\n                      case Token.SHEQ:\n                        decompilerToken = Token.EQ;\n                        break;\n                      case Token.SHNE:\n                        decompilerToken = Token.NE;\n                        break;\n                    }\n                }\n                decompiler.addToken(decompilerToken);\n                pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = shiftExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.IN:\n                if (inForInit)\n                    break;\n                // fall through\n              case Token.INSTANCEOF:\n              case Token.LE:\n              case Token.LT:\n              case Token.GE:\n              case Token.GT:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, shiftExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr()\n        throws IOException, ParserException\n    {\n        Node pn = addExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.LSH:\n              case Token.URSH:\n              case Token.RSH:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, addExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr()\n        throws IOException, ParserException\n    {\n        Node pn = mulExpr();\n        for (;;) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node mulExpr()\n        throws IOException, ParserException\n    {\n        Node pn = unaryExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.MUL:\n              case Token.DIV:\n              case Token.MOD:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, unaryExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node unaryExpr()\n        throws IOException, ParserException\n    {\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.TYPEOF:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createUnary(tt, unaryExpr());\n\n        case Token.ADD:\n            consumeToken();\n            // Convert to special POS token in decompiler and parse tree\n            decompiler.addToken(Token.POS);\n            return nf.createUnary(Token.POS, unaryExpr());\n\n        case Token.SUB:\n            consumeToken();\n            // Convert to special NEG token in decompiler and parse tree\n            decompiler.addToken(Token.NEG);\n            return nf.createUnary(Token.NEG, unaryExpr());\n\n        case Token.INC:\n        case Token.DEC:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createIncDec(tt, false, memberExpr(true));\n\n        case Token.DELPROP:\n            consumeToken();\n            decompiler.addToken(Token.DELPROP);\n            return nf.createUnary(Token.DELPROP, unaryExpr());\n\n        case Token.ERROR:\n            consumeToken();\n            break;\n\n        // XML stream encountered in expression.\n        case Token.LT:\n            if (compilerEnv.isXmlAvailable()) {\n                consumeToken();\n                Node pn = xmlInitializer();\n                return memberExprTail(true, pn);\n            }\n            // Fall thru to the default handling of RELOP\n\n        default:\n            Node pn = memberExpr(true);\n\n            // Don't look across a newline boundary for a postfix incop.\n            tt = peekTokenOrEOL();\n            if (tt == Token.INC || tt == Token.DEC) {\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, true, pn);\n            }\n            return pn;\n        }\n        return nf.createName(\"err\"); // Only reached on error.  Try to continue.\n\n    }\n\n    private Node xmlInitializer() throws IOException\n    {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        decompiler.addToken(Token.NEW);\n        decompiler.addToken(Token.DOT);\n\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n\n        decompiler.addName(fAnonymous ? \"XMLList\" : \"XML\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n\n        pn = null;\n        Node expr;\n        for (;;tt = ts.getNextXMLToken()) {\n            switch (tt) {\n            case Token.XML:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                mustMatchToken(Token.LC, \"msg.syntax\");\n                decompiler.addToken(Token.LC);\n                expr = (peekToken() == Token.RC)\n                    ? nf.createString(\"\")\n                    : expr(false);\n                mustMatchToken(Token.RC, \"msg.syntax\");\n                decompiler.addToken(Token.RC);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n                int nodeType;\n                if (ts.isXMLAttribute()) {\n                    nodeType = Token.ESCXMLATTR;\n                } else {\n                    nodeType = Token.ESCXMLTEXT;\n                }\n                expr = nf.createUnary(nodeType, expr);\n                pn = nf.createBinary(Token.ADD, pn, expr);\n                break;\n            case Token.XMLEND:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n\n                nf.addChildToBack(pnXML, pn);\n                return pnXML;\n            default:\n                reportError(\"msg.syntax\");\n                return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode)\n        throws IOException, ParserException\n    {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax)\n        throws IOException, ParserException\n    {\n        int tt;\n\n        Node pn;\n\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn)\n        throws IOException, ParserException\n    {\n      tailLoop:\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n\n              case Token.DOT:\n              case Token.DOTDOT:\n                {\n                    int memberTypeFlags;\n                    String s;\n\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    memberTypeFlags = 0;\n                    if (tt == Token.DOTDOT) {\n                        mustHaveXML();\n                        memberTypeFlags = Node.DESCENDANTS_FLAG;\n                    }\n                    if (!compilerEnv.isXmlAvailable()) {\n                        mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                        break;\n                    }\n\n                    tt = nextToken();\n                    switch (tt) {\n                      // handles: name, ns::name, ns::*, ns::[expr]\n                      case Token.NAME:\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = propertyName(pn, s, memberTypeFlags);\n                        break;\n\n                      // handles: *, *::name, *::*, *::[expr]\n                      case Token.MUL:\n                        decompiler.addName(\"*\");\n                        pn = propertyName(pn, \"*\", memberTypeFlags);\n                        break;\n\n                      // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                      //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                      case Token.XMLATTR:\n                        decompiler.addToken(Token.XMLATTR);\n                        pn = attributeAccess(pn, memberTypeFlags);\n                        break;\n\n                      default:\n                        reportError(\"msg.no.name.after.dot\");\n                    }\n                }\n                break;\n\n              case Token.DOTQUERY:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DOTQUERY);\n                pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                break;\n\n              case Token.LB:\n                consumeToken();\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), 0);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n\n              case Token.LP:\n                if (!allowCallSyntax) {\n                    break tailLoop;\n                }\n                consumeToken();\n                decompiler.addToken(Token.LP);\n                pn = nf.createCallOrNew(Token.CALL, pn);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n                break;\n\n              default:\n                break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags)\n        throws IOException\n    {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n\n        switch (tt) {\n          // handles: @name, @ns::name, @ns::*, @ns::[expr]\n          case Token.NAME:\n            {\n                String s = ts.getString();\n                decompiler.addName(s);\n                pn = propertyName(pn, s, memberTypeFlags);\n            }\n            break;\n\n          // handles: @*, @*::name, @*::*, @*::[expr]\n          case Token.MUL:\n            decompiler.addName(\"*\");\n            pn = propertyName(pn, \"*\", memberTypeFlags);\n            break;\n\n          // handles @[expr]\n          case Token.LB:\n            decompiler.addToken(Token.LB);\n            pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n            mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n            decompiler.addToken(Token.RB);\n            break;\n\n          default:\n            reportError(\"msg.no.name.after.xmlAttr\");\n            pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n            break;\n        }\n\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags)\n        throws IOException, ParserException\n    {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n\n            int tt = nextToken();\n            switch (tt) {\n              // handles name::name\n              case Token.NAME:\n                name = ts.getString();\n                decompiler.addName(name);\n                break;\n\n              // handles name::*\n              case Token.MUL:\n                decompiler.addName(\"*\");\n                name = \"*\";\n                break;\n\n              // handles name::[expr]\n              case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, namespace, expr(false),\n                                         memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                return pn;\n\n              default:\n                reportError(\"msg.no.name.after.coloncolon\");\n                name = \"?\";\n            }\n        }\n\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node primaryExpr()\n        throws IOException, ParserException\n    {\n        Node pn;\n\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n\n        switch(tt) {\n\n          case Token.FUNCTION:\n            return function(FunctionNode.FUNCTION_EXPRESSION);\n\n          case Token.LB: {\n            ObjArray elems = new ObjArray();\n            int skipCount = 0;\n            decompiler.addToken(Token.LB);\n            boolean after_lb_or_comma = true;\n            for (;;) {\n                tt = peekToken();\n\n                if (tt == Token.COMMA) {\n                    consumeToken();\n                    decompiler.addToken(Token.COMMA);\n                    if (!after_lb_or_comma) {\n                        after_lb_or_comma = true;\n                    } else {\n                        elems.add(null);\n                        ++skipCount;\n                    }\n                } else if (tt == Token.RB) {\n                    consumeToken();\n                    decompiler.addToken(Token.RB);\n                    break;\n                } else {\n                    if (!after_lb_or_comma) {\n                        reportError(\"msg.no.bracket.arg\");\n                    }\n                    elems.add(assignExpr(false));\n                    after_lb_or_comma = false;\n                }\n            }\n            return nf.createArrayLiteral(elems, skipCount);\n          }\n\n          case Token.LC: {\n            ObjArray elems = new ObjArray();\n            decompiler.addToken(Token.LC);\n            if (!matchToken(Token.RC)) {\n\n                boolean first = true;\n            commaloop:\n                do {\n                    Object property;\n\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    else\n                        first = false;\n\n                    tt = peekToken();\n                    switch(tt) {\n                      case Token.NAME:\n                      case Token.STRING:\n                        consumeToken();\n                        // map NAMEs to STRINGs in object literal context\n                        // but tell the decompiler the proper type\n                        String s = ts.getString();\n                        if (tt == Token.NAME) {\n                            decompiler.addName(s);\n                        } else {\n                            decompiler.addString(s);\n                        }\n                        property = ScriptRuntime.getIndexObject(s);\n                        break;\n\n                      case Token.NUMBER:\n                        consumeToken();\n                        double n = ts.getNumber();\n                        decompiler.addNumber(n);\n                        property = ScriptRuntime.getIndexObject(n);\n                        break;\n\n                      case Token.RC:\n                        // trailing comma is OK.\n                        break commaloop;\n                    default:\n                        reportError(\"msg.bad.prop\");\n                        break commaloop;\n                    }\n                    mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n\n                    // OBJLIT is used as ':' in object literal for\n                    // decompilation to solve spacing ambiguity.\n                    decompiler.addToken(Token.OBJECTLIT);\n                    elems.add(property);\n                    elems.add(assignExpr(false));\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n            }\n            decompiler.addToken(Token.RC);\n            return nf.createObjectLiteral(elems);\n          }\n\n          case Token.LP:\n\n            /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n            decompiler.addToken(Token.LP);\n            pn = expr(false);\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.RP, \"msg.no.paren\");\n            return pn;\n\n          case Token.XMLATTR:\n            mustHaveXML();\n            decompiler.addToken(Token.XMLATTR);\n            pn = attributeAccess(null, 0);\n            return pn;\n\n          case Token.NAME: {\n            String name = ts.getString();\n            if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                if (peekToken() == Token.COLON) {\n                    // Do not consume colon, it is used as unwind indicator\n                    // to return to statementHelper.\n                    // XXX Better way?\n                    return nf.createLabel(ts.getLineno());\n                }\n            }\n\n            decompiler.addName(name);\n            if (compilerEnv.isXmlAvailable()) {\n                pn = propertyName(null, name, 0);\n            } else {\n                pn = nf.createName(name);\n            }\n            return pn;\n          }\n\n          case Token.NUMBER: {\n            double n = ts.getNumber();\n            decompiler.addNumber(n);\n            return nf.createNumber(n);\n          }\n\n          case Token.STRING: {\n            String s = ts.getString();\n            decompiler.addString(s);\n            return nf.createString(s);\n          }\n\n          case Token.DIV:\n          case Token.ASSIGN_DIV: {\n            // Got / or /= which should be treated as regexp in fact\n            ts.readRegExp(tt);\n            String flags = ts.regExpFlags;\n            ts.regExpFlags = null;\n            String re = ts.getString();\n            decompiler.addRegexp(re, flags);\n            int index = currentScriptOrFn.addRegexp(re, flags);\n            return nf.createRegExp(index);\n          }\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.FALSE:\n          case Token.TRUE:\n            decompiler.addToken(tt);\n            return nf.createLeaf(tt);\n\n          case Token.RESERVED:\n            reportError(\"msg.reserved.id\");\n            break;\n\n          case Token.ERROR:\n            /* the scanner or one of its subroutines reported the error. */\n            break;\n\n          case Token.EOF:\n            reportError(\"msg.unexpected.eof\");\n            break;\n\n          default:\n            reportError(\"msg.syntax\");\n            break;\n        }\n        return null;    // should never reach here\n    }\n\n}\n\n"
-return.functionMethodBody.toString == "private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }"
+return.sourceCode.toString == "/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n *\n * The contents of this file are subject to the Netscape Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/NPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Variant Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Variant Code is Netscape\n * Communications Corporation.  Portions created by Netscape are\n * Copyright (C) 1997-1999 Netscape Communications Corporation. All\n * Rights Reserved.\n *\n * Contributor(s):\n * Mike Ang\n * Igor Bukanov\n * Ethan Hugg\n * Terry Lucas\n * Mike McCabe\n * Milen Nankov\n *\n * Alternatively, the contents of this file may be used under the\n * terms of the GNU Public License (the \"GPL\"), in which case the\n * provisions of the GPL are applicable instead of those above.\n * If you wish to allow use of your version of this file only\n * under the terms of the GPL and not to allow others to use your\n * version of this file under the NPL, indicate your decision by\n * deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL.  If you do not delete\n * the provisions above, a recipient may use your version of this\n * file under either the NPL or the GPL.\n */\n\npackage rhino._1.VARIANT;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\nimport rhino._1.mocks.*;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\n\npublic class Parser\n{\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int\n        CLEAR_TI_MASK  = 0xFFFF,   // mask to clear token information bits\n        TI_AFTER_EOL   = 1 << 16,  // first token of the source line\n        TI_CHECK_LABEL = 1 << 17;  // indicates to check for label\n\n    CompilerEnvirons compilerEnv;\n    private ErrorReporter errorReporter;\n    private String sourceURI;\n\n    private TokenStream ts;\n    private int currentFlaggedToken;\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n    private String encodedSource;\n\n// The following are per function variables and should be saved/restored\n// during function parsing.\n// XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n    private int nestingOfWith;\n    private Hashtable labelSet; // map of label names into nodes\n    private ObjArray loopSet;\n    private ObjArray loopAndSwitchSet;\n// end of per function variables\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException\n    {\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter)\n    {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv)\n    {\n        return new Decompiler();\n    }\n\n    void addWarning(String messageId, String messageArg)\n    {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.warning(message, sourceURI, ts.getLineno(),\n                              ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId)\n    {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(),\n                            ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId)\n    {\n        addError(messageId);\n\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken()\n        throws IOException\n    {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken()\n    {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken()\n        throws IOException\n    {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch)\n        throws IOException\n    {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL()\n        throws IOException\n    {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel()\n    {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId)\n        throws IOException, ParserException\n    {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML()\n    {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource()\n    {\n        return encodedSource;\n    }\n\n    public boolean eof()\n    {\n        return ts.eof();\n    }\n\n    boolean insideFunction()\n    {\n        return nestingOfFunction != 0;\n    }\n\n    private Node enterLoop(Node loopLabel)\n    {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        return loop;\n    }\n\n    private void exitLoop()\n    {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel)\n    {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch()\n    {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString,\n                                String sourceURI, int lineno)\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader,\n                                String sourceURI, int lineno)\n        throws IOException\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse()\n        throws IOException\n    {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n\n        try {\n            for (;;) {\n                int tt = peekToken();\n\n                if (tt <= Token.EOF) {\n                    break;\n                }\n\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\n                \"mag.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI,\n                                             ts.getLineno(), null, 0);\n        }\n\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno,\n                                             null, 0);\n        }\n\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset,\n                                                 sourceEndOffset);\n\n        nf.initScript(currentScriptOrFn, pn);\n\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        this.decompiler = null; // It helps GC\n\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody()\n        throws IOException\n    {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (;;) {\n                Node n;\n                int tt = peekToken();\n                switch (tt) {\n                  case Token.ERROR:\n                  case Token.EOF:\n                  case Token.RC:\n                    break bodyLoop;\n\n                  case Token.FUNCTION:\n                    consumeToken();\n                    n = function(FunctionNode.FUNCTION_STATEMENT);\n                    break;\n                  default:\n                    n = statement();\n                    break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n\n        return pn;\n    }\n\n    private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements()\n        throws IOException\n    {\n        Node pn = nf.createBlock(ts.getLineno());\n\n        int tt;\n        while((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n\n        return pn;\n    }\n\n    private Node condition()\n        throws IOException, ParserException\n    {\n        Node pn;\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n\n        // there's a check here in jsparse.c that corrects = to ==\n\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName()\n        throws IOException, ParserException\n    {\n        Node label = null;\n\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = (Node)labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n\n        return label;\n    }\n\n    private Node statement()\n        throws IOException\n    {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                return pn;\n            }\n        } catch (ParserException e) { }\n\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (;;) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch (tt) {\n              case Token.ERROR:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.SEMI:\n                break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    /**\n     * Whether the \"catch (e: e instanceof Exception) { ... }\" syntax\n     * is implemented.\n     */\n\n    private Node statementHelper(Node statementLabel)\n        throws IOException, ParserException\n    {\n        Node pn = null;\n\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n          case Token.IF: {\n            consumeToken();\n\n            decompiler.addToken(Token.IF);\n            int lineno = ts.getLineno();\n            Node cond = condition();\n            decompiler.addEOL(Token.LC);\n            Node ifTrue = statement();\n            Node ifFalse = null;\n            if (matchToken(Token.ELSE)) {\n                decompiler.addToken(Token.RC);\n                decompiler.addToken(Token.ELSE);\n                decompiler.addEOL(Token.LC);\n                ifFalse = statement();\n            }\n            decompiler.addEOL(Token.RC);\n            pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n            return pn;\n          }\n\n          case Token.SWITCH: {\n            consumeToken();\n\n            decompiler.addToken(Token.SWITCH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n            decompiler.addToken(Token.LP);\n            pn = enterSwitch(expr(false), lineno, statementLabel);\n            try {\n                mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                decompiler.addEOL(Token.LC);\n\n                boolean hasDefault = false;\n                switchLoop: for (;;) {\n                    tt = nextToken();\n                    Node caseExpression;\n                    switch (tt) {\n                      case Token.RC:\n                        break switchLoop;\n\n                      case Token.CASE:\n                        decompiler.addToken(Token.CASE);\n                        caseExpression = expr(false);\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      case Token.DEFAULT:\n                        if (hasDefault) {\n                            reportError(\"msg.double.switch.default\");\n                        }\n                        decompiler.addToken(Token.DEFAULT);\n                        hasDefault = true;\n                        caseExpression = null;\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      default:\n                        reportError(\"msg.bad.switch\");\n                        break switchLoop;\n                    }\n\n                    Node block = nf.createLeaf(Token.BLOCK);\n                    while ((tt = peekToken()) != Token.RC\n                           && tt != Token.CASE\n                           && tt != Token.DEFAULT\n                           && tt != Token.EOF)\n                    {\n                        nf.addChildToBack(block, statement());\n                    }\n\n                    // caseExpression == null => add default lable\n                    nf.addSwitchCase(pn, caseExpression, block);\n                }\n                decompiler.addEOL(Token.RC);\n                nf.closeSwitch(pn);\n            } finally {\n                exitSwitch();\n            }\n            return pn;\n          }\n\n          case Token.WHILE: {\n            consumeToken();\n            decompiler.addToken(Token.WHILE);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node cond = condition();\n                decompiler.addEOL(Token.LC);\n                Node body = statement();\n                decompiler.addEOL(Token.RC);\n                pn = nf.createWhile(loop, cond, body);\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.DO: {\n            consumeToken();\n            decompiler.addToken(Token.DO);\n            decompiler.addEOL(Token.LC);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node body = statement();\n                decompiler.addToken(Token.RC);\n                mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                decompiler.addToken(Token.WHILE);\n                Node cond = condition();\n                pn = nf.createDoWhile(loop, body, cond);\n            } finally {\n                exitLoop();\n            }\n            // Always auto-insert semicon to follow SpiderMonkey:\n            // It is required by EMAScript but is ignored by the rest of\n            // world, see bug 238945\n            matchToken(Token.SEMI);\n            decompiler.addEOL(Token.SEMI);\n            return pn;\n          }\n\n          case Token.FOR: {\n            consumeToken();\n            boolean isForEach = false;\n            decompiler.addToken(Token.FOR);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n\n                Node init;  // Node init is also foo in 'foo in Object'\n                Node cond;  // Node cond is also object in 'foo in Object'\n                Node incr = null; // to kill warning\n                Node body;\n\n                // See if this is a for each () instead of just a for ()\n                if (matchToken(Token.NAME)) {\n                    decompiler.addName(ts.getString());\n                    if (ts.getString().equals(\"each\")) {\n                        isForEach = true;\n                    } else {\n                        reportError(\"msg.no.paren.for\");\n                    }\n                }\n\n                mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                decompiler.addToken(Token.LP);\n                tt = peekToken();\n                if (tt == Token.SEMI) {\n                    init = nf.createLeaf(Token.EMPTY);\n                } else {\n                    if (tt == Token.VAR) {\n                        // set init to a var list or initial\n                        consumeToken();    // consume the 'var' token\n                        init = variables(true);\n                    }\n                    else {\n                        init = expr(true);\n                    }\n                }\n\n                if (matchToken(Token.IN)) {\n                    decompiler.addToken(Token.IN);\n                    // 'cond' is the object over which we're iterating\n                    cond = expr(false);\n                } else {  // ordinary for loop\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.SEMI) {\n                        // no loop condition\n                        cond = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        cond = expr(false);\n                    }\n\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.RP) {\n                        incr = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        incr = expr(false);\n                    }\n                }\n\n                mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                decompiler.addToken(Token.RP);\n                decompiler.addEOL(Token.LC);\n                body = statement();\n                decompiler.addEOL(Token.RC);\n\n                if (incr == null) {\n                    // cond could be null if 'in obj' got eaten\n                    // by the init node.\n                    pn = nf.createForIn(loop, init, cond, body, isForEach);\n                } else {\n                    pn = nf.createFor(loop, init, cond, incr, body);\n                }\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.TRY: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            Node tryblock;\n            Node catchblocks = null;\n            Node finallyblock = null;\n\n            decompiler.addToken(Token.TRY);\n            decompiler.addEOL(Token.LC);\n            tryblock = statement();\n            decompiler.addEOL(Token.RC);\n\n            catchblocks = nf.createLeaf(Token.BLOCK);\n\n            boolean sawDefaultCatch = false;\n            int peek = peekToken();\n            if (peek == Token.CATCH) {\n                while (matchToken(Token.CATCH)) {\n                    if (sawDefaultCatch) {\n                        reportError(\"msg.catch.unreachable\");\n                    }\n                    decompiler.addToken(Token.CATCH);\n                    mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                    decompiler.addToken(Token.LP);\n\n                    mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                    String varName = ts.getString();\n                    decompiler.addName(varName);\n\n                    Node catchCond = null;\n                    if (matchToken(Token.IF)) {\n                        decompiler.addToken(Token.IF);\n                        catchCond = expr(false);\n                    } else {\n                        sawDefaultCatch = true;\n                    }\n\n                    mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                    decompiler.addToken(Token.RP);\n                    mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                    decompiler.addEOL(Token.LC);\n\n                    nf.addChildToBack(catchblocks,\n                        nf.createCatch(varName, catchCond,\n                                       statements(),\n                                       ts.getLineno()));\n\n                    mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                    decompiler.addEOL(Token.RC);\n                }\n            } else if (peek != Token.FINALLY) {\n                mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n            }\n\n            if (matchToken(Token.FINALLY)) {\n                decompiler.addToken(Token.FINALLY);\n                decompiler.addEOL(Token.LC);\n                finallyblock = statement();\n                decompiler.addEOL(Token.RC);\n            }\n\n            pn = nf.createTryCatchFinally(tryblock, catchblocks,\n                                          finallyblock, lineno);\n\n            return pn;\n          }\n\n          case Token.THROW: {\n            consumeToken();\n            if (peekTokenOrEOL() == Token.EOL) {\n                // ECMAScript does not allow new lines before throw expression,\n                // see bug 256617\n                reportError(\"msg.bad.throw.eol\");\n            }\n\n            int lineno = ts.getLineno();\n            decompiler.addToken(Token.THROW);\n            pn = nf.createThrow(expr(false), lineno);\n            break;\n          }\n\n          case Token.BREAK: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.BREAK);\n\n            // matchJumpLabelName only matches if there is one\n            Node breakStatement = matchJumpLabelName();\n            if (breakStatement == null) {\n                if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                    reportError(\"msg.bad.break\");\n                    return null;\n                }\n                breakStatement = (Node)loopAndSwitchSet.peek();\n            }\n            pn = nf.createBreak(breakStatement, lineno);\n            break;\n          }\n\n          case Token.CONTINUE: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.CONTINUE);\n\n            Node loop;\n            // matchJumpLabelName only matches if there is one\n            Node label = matchJumpLabelName();\n            if (label == null) {\n                if (loopSet == null || loopSet.size() == 0) {\n                    reportError(\"msg.continue.outside\");\n                    return null;\n                }\n                loop = (Node)loopSet.peek();\n            } else {\n                loop = nf.getLabelLoop(label);\n                if (loop == null) {\n                    reportError(\"msg.continue.nonloop\");\n                    return null;\n                }\n            }\n            pn = nf.createContinue(loop, lineno);\n            break;\n          }\n\n          case Token.WITH: {\n            consumeToken();\n\n            decompiler.addToken(Token.WITH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.with\");\n            decompiler.addToken(Token.LP);\n            Node obj = expr(false);\n            mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n            decompiler.addToken(Token.RP);\n            decompiler.addEOL(Token.LC);\n\n            ++nestingOfWith;\n            Node body;\n            try {\n                body = statement();\n            } finally {\n                --nestingOfWith;\n            }\n\n            decompiler.addEOL(Token.RC);\n\n            pn = nf.createWith(obj, body, lineno);\n            return pn;\n          }\n\n          case Token.VAR: {\n            consumeToken();\n            pn = variables(false);\n            break;\n          }\n\n          case Token.RETURN: {\n            if (!insideFunction()) {\n                reportError(\"msg.bad.return\");\n            }\n            consumeToken();\n            decompiler.addToken(Token.RETURN);\n            int lineno = ts.getLineno();\n\n            Node retExpr;\n            /* This is ugly, but we don't want to require a semicolon. */\n            tt = peekTokenOrEOL();\n            switch (tt) {\n              case Token.SEMI:\n              case Token.RC:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.ERROR:\n                retExpr = null;\n                break;\n              default:\n                retExpr = expr(false);\n            }\n            pn = nf.createReturn(retExpr, lineno);\n            break;\n          }\n\n          case Token.LC:\n            consumeToken();\n            if (statementLabel != null) {\n                decompiler.addToken(Token.LC);\n            }\n            pn = statements();\n            mustMatchToken(Token.RC, \"msg.no.brace.block\");\n            if (statementLabel != null) {\n                decompiler.addEOL(Token.RC);\n            }\n            return pn;\n\n          case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n          case Token.SEMI:\n            consumeToken();\n            pn = nf.createLeaf(Token.EMPTY);\n            return pn;\n\n          case Token.FUNCTION: {\n            consumeToken();\n            pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n            return pn;\n          }\n\n          case Token.DEFAULT :\n            consumeToken();\n            mustHaveXML();\n\n            decompiler.addToken(Token.DEFAULT);\n            int nsLine = ts.getLineno();\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"xml\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"namespace\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!matchToken(Token.ASSIGN)) {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addToken(Token.ASSIGN);\n\n            Node expr = expr(false);\n            pn = nf.createDefaultNamespace(expr, nsLine);\n            break;\n\n          case Token.NAME: {\n            int lineno = ts.getLineno();\n            String name = ts.getString();\n            setCheckForLabel();\n            pn = expr(false);\n            if (pn.getType() != Token.LABEL) {\n                pn = nf.createExprStatement(pn, lineno);\n            } else {\n                // Parsed the label: push back token should be\n                // colon that primaryExpr left untouched.\n                if (peekToken() != Token.COLON) Kit.codeBug();\n                consumeToken();\n                // depend on decompiling lookahead to guess that that\n                // last name was a label.\n                decompiler.addName(name);\n                decompiler.addEOL(Token.COLON);\n\n                if (labelSet == null) {\n                    labelSet = new Hashtable();\n                } else if (labelSet.containsKey(name)) {\n                    reportError(\"msg.dup.label\");\n                }\n\n                boolean firstLabel;\n                if (statementLabel == null) {\n                    firstLabel = true;\n                    statementLabel = pn;\n                } else {\n                    // Discard multiple label nodes and use only\n                    // the first: it allows to simplify IRFactory\n                    firstLabel = false;\n                }\n                labelSet.put(name, statementLabel);\n                try {\n                    pn = statementHelper(statementLabel);\n                } finally {\n                    labelSet.remove(name);\n                }\n                if (firstLabel) {\n                    pn = nf.createLabeledStatement(statementLabel, pn);\n                }\n                return pn;\n            }\n            break;\n          }\n\n          default: {\n            int lineno = ts.getLineno();\n            pn = expr(false);\n            pn = nf.createExprStatement(pn, lineno);\n            break;\n          }\n        }\n\n        int ttFlagged = peekFlaggedToken();\n        switch (ttFlagged & CLEAR_TI_MASK) {\n          case Token.SEMI:\n            // Consume ';' as a part of expression\n            consumeToken();\n            break;\n          case Token.ERROR:\n          case Token.EOF:\n          case Token.RC:\n            // Autoinsert ;\n            break;\n          default:\n            if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                // Report error if no EOL or autoinsert ; otherwise\n                reportError(\"msg.no.semi.stmt\");\n            }\n            break;\n        }\n        decompiler.addEOL(Token.SEMI);\n\n        return pn;\n    }\n\n    private Node variables(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = nf.createVariables(ts.getLineno());\n        boolean first = true;\n\n        decompiler.addToken(Token.VAR);\n\n        for (;;) {\n            Node name;\n            Node init;\n            mustMatchToken(Token.NAME, \"msg.bad.var\");\n            String s = ts.getString();\n\n            if (!first)\n                decompiler.addToken(Token.COMMA);\n            first = false;\n\n            decompiler.addName(s);\n            currentScriptOrFn.addVar(s);\n            name = nf.createName(s);\n\n            // omitted check for argument hiding\n\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n\n                init = assignExpr(inForInit);\n                nf.addChildToBack(name, init);\n            }\n            nf.addChildToBack(pn, name);\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return pn;\n    }\n\n    private Node expr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = condExpr(inForInit);\n\n        int tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node ifTrue;\n        Node ifFalse;\n\n        Node pn = orExpr(inForInit);\n\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = relExpr(inForInit);\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.EQ:\n              case Token.NE:\n              case Token.SHEQ:\n              case Token.SHNE:\n                consumeToken();\n                int decompilerToken = tt;\n                int parseToken = tt;\n                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                    // JavaScript 1.2 uses shallow equality for == and != .\n                    // In addition, convert === and !== for decompiler into\n                    // == and != since the decompiler is supposed to show\n                    // canonical source and in 1.2 ===, !== are allowed\n                    // only as an alias to ==, !=.\n                    switch (tt) {\n                      case Token.EQ:\n                        parseToken = Token.SHEQ;\n                        break;\n                      case Token.NE:\n                        parseToken = Token.SHNE;\n                        break;\n                      case Token.SHEQ:\n                        decompilerToken = Token.EQ;\n                        break;\n                      case Token.SHNE:\n                        decompilerToken = Token.NE;\n                        break;\n                    }\n                }\n                decompiler.addToken(decompilerToken);\n                pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = shiftExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.IN:\n                if (inForInit)\n                    break;\n                // fall through\n              case Token.INSTANCEOF:\n              case Token.LE:\n              case Token.LT:\n              case Token.GE:\n              case Token.GT:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, shiftExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr()\n        throws IOException, ParserException\n    {\n        Node pn = addExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.LSH:\n              case Token.URSH:\n              case Token.RSH:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, addExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr()\n        throws IOException, ParserException\n    {\n        Node pn = mulExpr();\n        for (;;) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node mulExpr()\n        throws IOException, ParserException\n    {\n        Node pn = unaryExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.MUL:\n              case Token.DIV:\n              case Token.MOD:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, unaryExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node unaryExpr()\n        throws IOException, ParserException\n    {\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.TYPEOF:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createUnary(tt, unaryExpr());\n\n        case Token.ADD:\n            consumeToken();\n            // Convert to special POS token in decompiler and parse tree\n            decompiler.addToken(Token.POS);\n            return nf.createUnary(Token.POS, unaryExpr());\n\n        case Token.SUB:\n            consumeToken();\n            // Convert to special NEG token in decompiler and parse tree\n            decompiler.addToken(Token.NEG);\n            return nf.createUnary(Token.NEG, unaryExpr());\n\n        case Token.INC:\n        case Token.DEC:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createIncDec(tt, false, memberExpr(true));\n\n        case Token.DELPROP:\n            consumeToken();\n            decompiler.addToken(Token.DELPROP);\n            return nf.createUnary(Token.DELPROP, unaryExpr());\n\n        case Token.ERROR:\n            consumeToken();\n            break;\n\n        // XML stream encountered in expression.\n        case Token.LT:\n            if (compilerEnv.isXmlAvailable()) {\n                consumeToken();\n                Node pn = xmlInitializer();\n                return memberExprTail(true, pn);\n            }\n            // Fall thru to the default handling of RELOP\n\n        default:\n            Node pn = memberExpr(true);\n\n            // Don't look across a newline boundary for a postfix incop.\n            tt = peekTokenOrEOL();\n            if (tt == Token.INC || tt == Token.DEC) {\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, true, pn);\n            }\n            return pn;\n        }\n        return nf.createName(\"err\"); // Only reached on error.  Try to continue.\n\n    }\n\n    private Node xmlInitializer() throws IOException\n    {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        decompiler.addToken(Token.NEW);\n        decompiler.addToken(Token.DOT);\n\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n\n        decompiler.addName(fAnonymous ? \"XMLList\" : \"XML\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n\n        pn = null;\n        Node expr;\n        for (;;tt = ts.getNextXMLToken()) {\n            switch (tt) {\n            case Token.XML:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                mustMatchToken(Token.LC, \"msg.syntax\");\n                decompiler.addToken(Token.LC);\n                expr = (peekToken() == Token.RC)\n                    ? nf.createString(\"\")\n                    : expr(false);\n                mustMatchToken(Token.RC, \"msg.syntax\");\n                decompiler.addToken(Token.RC);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n                int nodeType;\n                if (ts.isXMLAttribute()) {\n                    nodeType = Token.ESCXMLATTR;\n                } else {\n                    nodeType = Token.ESCXMLTEXT;\n                }\n                expr = nf.createUnary(nodeType, expr);\n                pn = nf.createBinary(Token.ADD, pn, expr);\n                break;\n            case Token.XMLEND:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n\n                nf.addChildToBack(pnXML, pn);\n                return pnXML;\n            default:\n                reportError(\"msg.syntax\");\n                return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode)\n        throws IOException, ParserException\n    {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax)\n        throws IOException, ParserException\n    {\n        int tt;\n\n        Node pn;\n\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn)\n        throws IOException, ParserException\n    {\n      tailLoop:\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n\n              case Token.DOT:\n              case Token.DOTDOT:\n                {\n                    int memberTypeFlags;\n                    String s;\n\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    memberTypeFlags = 0;\n                    if (tt == Token.DOTDOT) {\n                        mustHaveXML();\n                        memberTypeFlags = Node.DESCENDANTS_FLAG;\n                    }\n                    if (!compilerEnv.isXmlAvailable()) {\n                        mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                        break;\n                    }\n\n                    tt = nextToken();\n                    switch (tt) {\n                      // handles: name, ns::name, ns::*, ns::[expr]\n                      case Token.NAME:\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = propertyName(pn, s, memberTypeFlags);\n                        break;\n\n                      // handles: *, *::name, *::*, *::[expr]\n                      case Token.MUL:\n                        decompiler.addName(\"*\");\n                        pn = propertyName(pn, \"*\", memberTypeFlags);\n                        break;\n\n                      // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                      //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                      case Token.XMLATTR:\n                        decompiler.addToken(Token.XMLATTR);\n                        pn = attributeAccess(pn, memberTypeFlags);\n                        break;\n\n                      default:\n                        reportError(\"msg.no.name.after.dot\");\n                    }\n                }\n                break;\n\n              case Token.DOTQUERY:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DOTQUERY);\n                pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                break;\n\n              case Token.LB:\n                consumeToken();\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), 0);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n\n              case Token.LP:\n                if (!allowCallSyntax) {\n                    break tailLoop;\n                }\n                consumeToken();\n                decompiler.addToken(Token.LP);\n                pn = nf.createCallOrNew(Token.CALL, pn);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n                break;\n\n              default:\n                break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags)\n        throws IOException\n    {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n\n        switch (tt) {\n          // handles: @name, @ns::name, @ns::*, @ns::[expr]\n          case Token.NAME:\n            {\n                String s = ts.getString();\n                decompiler.addName(s);\n                pn = propertyName(pn, s, memberTypeFlags);\n            }\n            break;\n\n          // handles: @*, @*::name, @*::*, @*::[expr]\n          case Token.MUL:\n            decompiler.addName(\"*\");\n            pn = propertyName(pn, \"*\", memberTypeFlags);\n            break;\n\n          // handles @[expr]\n          case Token.LB:\n            decompiler.addToken(Token.LB);\n            pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n            mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n            decompiler.addToken(Token.RB);\n            break;\n\n          default:\n            reportError(\"msg.no.name.after.xmlAttr\");\n            pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n            break;\n        }\n\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags)\n        throws IOException, ParserException\n    {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n\n            int tt = nextToken();\n            switch (tt) {\n              // handles name::name\n              case Token.NAME:\n                name = ts.getString();\n                decompiler.addName(name);\n                break;\n\n              // handles name::*\n              case Token.MUL:\n                decompiler.addName(\"*\");\n                name = \"*\";\n                break;\n\n              // handles name::[expr]\n              case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, namespace, expr(false),\n                                         memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                return pn;\n\n              default:\n                reportError(\"msg.no.name.after.coloncolon\");\n                name = \"?\";\n            }\n        }\n\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node primaryExpr()\n        throws IOException, ParserException\n    {\n        Node pn;\n\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n\n        switch(tt) {\n\n          case Token.FUNCTION:\n            return function(FunctionNode.FUNCTION_EXPRESSION);\n\n          case Token.LB: {\n            ObjArray elems = new ObjArray();\n            int skipCount = 0;\n            decompiler.addToken(Token.LB);\n            boolean after_lb_or_comma = true;\n            for (;;) {\n                tt = peekToken();\n\n                if (tt == Token.COMMA) {\n                    consumeToken();\n                    decompiler.addToken(Token.COMMA);\n                    if (!after_lb_or_comma) {\n                        after_lb_or_comma = true;\n                    } else {\n                        elems.add(null);\n                        ++skipCount;\n                    }\n                } else if (tt == Token.RB) {\n                    consumeToken();\n                    decompiler.addToken(Token.RB);\n                    break;\n                } else {\n                    if (!after_lb_or_comma) {\n                        reportError(\"msg.no.bracket.arg\");\n                    }\n                    elems.add(assignExpr(false));\n                    after_lb_or_comma = false;\n                }\n            }\n            return nf.createArrayLiteral(elems, skipCount);\n          }\n\n          case Token.LC: {\n            ObjArray elems = new ObjArray();\n            decompiler.addToken(Token.LC);\n            if (!matchToken(Token.RC)) {\n\n                boolean first = true;\n            commaloop:\n                do {\n                    Object property;\n\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    else\n                        first = false;\n\n                    tt = peekToken();\n                    switch(tt) {\n                      case Token.NAME:\n                      case Token.STRING:\n                        consumeToken();\n                        // map NAMEs to STRINGs in object literal context\n                        // but tell the decompiler the proper type\n                        String s = ts.getString();\n                        if (tt == Token.NAME) {\n                            decompiler.addName(s);\n                        } else {\n                            decompiler.addString(s);\n                        }\n                        property = ScriptRuntime.getIndexObject(s);\n                        break;\n\n                      case Token.NUMBER:\n                        consumeToken();\n                        double n = ts.getNumber();\n                        decompiler.addNumber(n);\n                        property = ScriptRuntime.getIndexObject(n);\n                        break;\n\n                      case Token.RC:\n                        // trailing comma is OK.\n                        break commaloop;\n                    default:\n                        reportError(\"msg.bad.prop\");\n                        break commaloop;\n                    }\n                    mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n\n                    // OBJLIT is used as ':' in object literal for\n                    // decompilation to solve spacing ambiguity.\n                    decompiler.addToken(Token.OBJECTLIT);\n                    elems.add(property);\n                    elems.add(assignExpr(false));\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n            }\n            decompiler.addToken(Token.RC);\n            return nf.createObjectLiteral(elems);\n          }\n\n          case Token.LP:\n\n            /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n            decompiler.addToken(Token.LP);\n            pn = expr(false);\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.RP, \"msg.no.paren\");\n            return pn;\n\n          case Token.XMLATTR:\n            mustHaveXML();\n            decompiler.addToken(Token.XMLATTR);\n            pn = attributeAccess(null, 0);\n            return pn;\n\n          case Token.NAME: {\n            String name = ts.getString();\n            if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                if (peekToken() == Token.COLON) {\n                    // Do not consume colon, it is used as unwind indicator\n                    // to return to statementHelper.\n                    // XXX Better way?\n                    return nf.createLabel(ts.getLineno());\n                }\n            }\n\n            decompiler.addName(name);\n            if (compilerEnv.isXmlAvailable()) {\n                pn = propertyName(null, name, 0);\n            } else {\n                pn = nf.createName(name);\n            }\n            return pn;\n          }\n\n          case Token.NUMBER: {\n            double n = ts.getNumber();\n            decompiler.addNumber(n);\n            return nf.createNumber(n);\n          }\n\n          case Token.STRING: {\n            String s = ts.getString();\n            decompiler.addString(s);\n            return nf.createString(s);\n          }\n\n          case Token.DIV:\n          case Token.ASSIGN_DIV: {\n            // Got / or /= which should be treated as regexp in fact\n            ts.readRegExp(tt);\n            String flags = ts.regExpFlags;\n            ts.regExpFlags = null;\n            String re = ts.getString();\n            decompiler.addRegexp(re, flags);\n            int index = currentScriptOrFn.addRegexp(re, flags);\n            return nf.createRegExp(index);\n          }\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.FALSE:\n          case Token.TRUE:\n            decompiler.addToken(tt);\n            return nf.createLeaf(tt);\n\n          case Token.RESERVED:\n            reportError(\"msg.reserved.id\");\n            break;\n\n          case Token.ERROR:\n            /* the scanner or one of its subroutines reported the error. */\n            break;\n\n          case Token.EOF:\n            reportError(\"msg.unexpected.eof\");\n            break;\n\n          default:\n            reportError(\"msg.syntax\");\n            break;\n        }\n        return null;    // should never reach here\n    }\n\n}"
+return.functionMethodBody.toString == "private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }"
 ===========================================================================
 rhino._1.Driver:::OBJECT
 this.parser != null
@@ -47,8 +52,8 @@
 this.variant != null
 this.variant.toString == "VARIANT"
 this.sourceCode != null
-this.sourceCode.toString == "/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n *\n * The contents of this file are subject to the Netscape Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/NPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Variant Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Variant Code is Netscape\n * Communications Corporation.  Portions created by Netscape are\n * Copyright (C) 1997-1999 Netscape Communications Corporation. All\n * Rights Reserved.\n *\n * Contributor(s):\n * Mike Ang\n * Igor Bukanov\n * Ethan Hugg\n * Terry Lucas\n * Mike McCabe\n * Milen Nankov\n *\n * Alternatively, the contents of this file may be used under the\n * terms of the GNU Public License (the \"GPL\"), in which case the\n * provisions of the GPL are applicable instead of those above.\n * If you wish to allow use of your version of this file only\n * under the terms of the GPL and not to allow others to use your\n * version of this file under the NPL, indicate your decision by\n * deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL.  If you do not delete\n * the provisions above, a recipient may use your version of this\n * file under either the NPL or the GPL.\n */\n\npackage rhino._1.VARIANT;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\nimport rhino._1.mocks.*;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\n\npublic class Parser\n{\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int\n        CLEAR_TI_MASK  = 0xFFFF,   // mask to clear token information bits\n        TI_AFTER_EOL   = 1 << 16,  // first token of the source line\n        TI_CHECK_LABEL = 1 << 17;  // indicates to check for label\n\n    CompilerEnvirons compilerEnv;\n    private ErrorReporter errorReporter;\n    private String sourceURI;\n\n    private TokenStream ts;\n    private int currentFlaggedToken;\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n    private String encodedSource;\n\n// The following are per function variables and should be saved/restored\n// during function parsing.\n// XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n    private int nestingOfWith;\n    private Hashtable labelSet; // map of label names into nodes\n    private ObjArray loopSet;\n    private ObjArray loopAndSwitchSet;\n// end of per function variables\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException\n    {\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter)\n    {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv)\n    {\n        return new Decompiler();\n    }\n\n    void addWarning(String messageId, String messageArg)\n    {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.warning(message, sourceURI, ts.getLineno(),\n                              ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId)\n    {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(),\n                            ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId)\n    {\n        addError(messageId);\n\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken()\n        throws IOException\n    {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken()\n    {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken()\n        throws IOException\n    {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch)\n        throws IOException\n    {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL()\n        throws IOException\n    {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel()\n    {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId)\n        throws IOException, ParserException\n    {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML()\n    {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource()\n    {\n        return encodedSource;\n    }\n\n    public boolean eof()\n    {\n        return ts.eof();\n    }\n\n    boolean insideFunction()\n    {\n        return nestingOfFunction != 0;\n    }\n\n    private Node enterLoop(Node loopLabel)\n    {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        return loop;\n    }\n\n    private void exitLoop()\n    {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel)\n    {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch()\n    {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString,\n                                String sourceURI, int lineno)\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader,\n                                String sourceURI, int lineno)\n        throws IOException\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse()\n        throws IOException\n    {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n\n        try {\n            for (;;) {\n                int tt = peekToken();\n\n                if (tt <= Token.EOF) {\n                    break;\n                }\n\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\n                \"mag.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI,\n                                             ts.getLineno(), null, 0);\n        }\n\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno,\n                                             null, 0);\n        }\n\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset,\n                                                 sourceEndOffset);\n\n        nf.initScript(currentScriptOrFn, pn);\n\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        this.decompiler = null; // It helps GC\n\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody()\n        throws IOException\n    {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (;;) {\n                Node n;\n                int tt = peekToken();\n                switch (tt) {\n                  case Token.ERROR:\n                  case Token.EOF:\n                  case Token.RC:\n                    break bodyLoop;\n\n                  case Token.FUNCTION:\n                    consumeToken();\n                    n = function(FunctionNode.FUNCTION_STATEMENT);\n                    break;\n                  default:\n                    n = statement();\n                    break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n\n        return pn;\n    }\n\n    private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements()\n        throws IOException\n    {\n        Node pn = nf.createBlock(ts.getLineno());\n\n        int tt;\n        while((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n\n        return pn;\n    }\n\n    private Node condition()\n        throws IOException, ParserException\n    {\n        Node pn;\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n\n        // there's a check here in jsparse.c that corrects = to ==\n\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName()\n        throws IOException, ParserException\n    {\n        Node label = null;\n\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = (Node)labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n\n        return label;\n    }\n\n    private Node statement()\n        throws IOException\n    {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                return pn;\n            }\n        } catch (ParserException e) { }\n\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (;;) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch (tt) {\n              case Token.ERROR:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.SEMI:\n                break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    /**\n     * Whether the \"catch (e: e instanceof Exception) { ... }\" syntax\n     * is implemented.\n     */\n\n    private Node statementHelper(Node statementLabel)\n        throws IOException, ParserException\n    {\n        Node pn = null;\n\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n          case Token.IF: {\n            consumeToken();\n\n            decompiler.addToken(Token.IF);\n            int lineno = ts.getLineno();\n            Node cond = condition();\n            decompiler.addEOL(Token.LC);\n            Node ifTrue = statement();\n            Node ifFalse = null;\n            if (matchToken(Token.ELSE)) {\n                decompiler.addToken(Token.RC);\n                decompiler.addToken(Token.ELSE);\n                decompiler.addEOL(Token.LC);\n                ifFalse = statement();\n            }\n            decompiler.addEOL(Token.RC);\n            pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n            return pn;\n          }\n\n          case Token.SWITCH: {\n            consumeToken();\n\n            decompiler.addToken(Token.SWITCH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n            decompiler.addToken(Token.LP);\n            pn = enterSwitch(expr(false), lineno, statementLabel);\n            try {\n                mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                decompiler.addEOL(Token.LC);\n\n                boolean hasDefault = false;\n                switchLoop: for (;;) {\n                    tt = nextToken();\n                    Node caseExpression;\n                    switch (tt) {\n                      case Token.RC:\n                        break switchLoop;\n\n                      case Token.CASE:\n                        decompiler.addToken(Token.CASE);\n                        caseExpression = expr(false);\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      case Token.DEFAULT:\n                        if (hasDefault) {\n                            reportError(\"msg.double.switch.default\");\n                        }\n                        decompiler.addToken(Token.DEFAULT);\n                        hasDefault = true;\n                        caseExpression = null;\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      default:\n                        reportError(\"msg.bad.switch\");\n                        break switchLoop;\n                    }\n\n                    Node block = nf.createLeaf(Token.BLOCK);\n                    while ((tt = peekToken()) != Token.RC\n                           && tt != Token.CASE\n                           && tt != Token.DEFAULT\n                           && tt != Token.EOF)\n                    {\n                        nf.addChildToBack(block, statement());\n                    }\n\n                    // caseExpression == null => add default lable\n                    nf.addSwitchCase(pn, caseExpression, block);\n                }\n                decompiler.addEOL(Token.RC);\n                nf.closeSwitch(pn);\n            } finally {\n                exitSwitch();\n            }\n            return pn;\n          }\n\n          case Token.WHILE: {\n            consumeToken();\n            decompiler.addToken(Token.WHILE);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node cond = condition();\n                decompiler.addEOL(Token.LC);\n                Node body = statement();\n                decompiler.addEOL(Token.RC);\n                pn = nf.createWhile(loop, cond, body);\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.DO: {\n            consumeToken();\n            decompiler.addToken(Token.DO);\n            decompiler.addEOL(Token.LC);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node body = statement();\n                decompiler.addToken(Token.RC);\n                mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                decompiler.addToken(Token.WHILE);\n                Node cond = condition();\n                pn = nf.createDoWhile(loop, body, cond);\n            } finally {\n                exitLoop();\n            }\n            // Always auto-insert semicon to follow SpiderMonkey:\n            // It is required by EMAScript but is ignored by the rest of\n            // world, see bug 238945\n            matchToken(Token.SEMI);\n            decompiler.addEOL(Token.SEMI);\n            return pn;\n          }\n\n          case Token.FOR: {\n            consumeToken();\n            boolean isForEach = false;\n            decompiler.addToken(Token.FOR);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n\n                Node init;  // Node init is also foo in 'foo in Object'\n                Node cond;  // Node cond is also object in 'foo in Object'\n                Node incr = null; // to kill warning\n                Node body;\n\n                // See if this is a for each () instead of just a for ()\n                if (matchToken(Token.NAME)) {\n                    decompiler.addName(ts.getString());\n                    if (ts.getString().equals(\"each\")) {\n                        isForEach = true;\n                    } else {\n                        reportError(\"msg.no.paren.for\");\n                    }\n                }\n\n                mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                decompiler.addToken(Token.LP);\n                tt = peekToken();\n                if (tt == Token.SEMI) {\n                    init = nf.createLeaf(Token.EMPTY);\n                } else {\n                    if (tt == Token.VAR) {\n                        // set init to a var list or initial\n                        consumeToken();    // consume the 'var' token\n                        init = variables(true);\n                    }\n                    else {\n                        init = expr(true);\n                    }\n                }\n\n                if (matchToken(Token.IN)) {\n                    decompiler.addToken(Token.IN);\n                    // 'cond' is the object over which we're iterating\n                    cond = expr(false);\n                } else {  // ordinary for loop\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.SEMI) {\n                        // no loop condition\n                        cond = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        cond = expr(false);\n                    }\n\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.RP) {\n                        incr = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        incr = expr(false);\n                    }\n                }\n\n                mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                decompiler.addToken(Token.RP);\n                decompiler.addEOL(Token.LC);\n                body = statement();\n                decompiler.addEOL(Token.RC);\n\n                if (incr == null) {\n                    // cond could be null if 'in obj' got eaten\n                    // by the init node.\n                    pn = nf.createForIn(loop, init, cond, body, isForEach);\n                } else {\n                    pn = nf.createFor(loop, init, cond, incr, body);\n                }\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.TRY: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            Node tryblock;\n            Node catchblocks = null;\n            Node finallyblock = null;\n\n            decompiler.addToken(Token.TRY);\n            decompiler.addEOL(Token.LC);\n            tryblock = statement();\n            decompiler.addEOL(Token.RC);\n\n            catchblocks = nf.createLeaf(Token.BLOCK);\n\n            boolean sawDefaultCatch = false;\n            int peek = peekToken();\n            if (peek == Token.CATCH) {\n                while (matchToken(Token.CATCH)) {\n                    if (sawDefaultCatch) {\n                        reportError(\"msg.catch.unreachable\");\n                    }\n                    decompiler.addToken(Token.CATCH);\n                    mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                    decompiler.addToken(Token.LP);\n\n                    mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                    String varName = ts.getString();\n                    decompiler.addName(varName);\n\n                    Node catchCond = null;\n                    if (matchToken(Token.IF)) {\n                        decompiler.addToken(Token.IF);\n                        catchCond = expr(false);\n                    } else {\n                        sawDefaultCatch = true;\n                    }\n\n                    mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                    decompiler.addToken(Token.RP);\n                    mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                    decompiler.addEOL(Token.LC);\n\n                    nf.addChildToBack(catchblocks,\n                        nf.createCatch(varName, catchCond,\n                                       statements(),\n                                       ts.getLineno()));\n\n                    mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                    decompiler.addEOL(Token.RC);\n                }\n            } else if (peek != Token.FINALLY) {\n                mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n            }\n\n            if (matchToken(Token.FINALLY)) {\n                decompiler.addToken(Token.FINALLY);\n                decompiler.addEOL(Token.LC);\n                finallyblock = statement();\n                decompiler.addEOL(Token.RC);\n            }\n\n            pn = nf.createTryCatchFinally(tryblock, catchblocks,\n                                          finallyblock, lineno);\n\n            return pn;\n          }\n\n          case Token.THROW: {\n            consumeToken();\n            if (peekTokenOrEOL() == Token.EOL) {\n                // ECMAScript does not allow new lines before throw expression,\n                // see bug 256617\n                reportError(\"msg.bad.throw.eol\");\n            }\n\n            int lineno = ts.getLineno();\n            decompiler.addToken(Token.THROW);\n            pn = nf.createThrow(expr(false), lineno);\n            break;\n          }\n\n          case Token.BREAK: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.BREAK);\n\n            // matchJumpLabelName only matches if there is one\n            Node breakStatement = matchJumpLabelName();\n            if (breakStatement == null) {\n                if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                    reportError(\"msg.bad.break\");\n                    return null;\n                }\n                breakStatement = (Node)loopAndSwitchSet.peek();\n            }\n            pn = nf.createBreak(breakStatement, lineno);\n            break;\n          }\n\n          case Token.CONTINUE: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.CONTINUE);\n\n            Node loop;\n            // matchJumpLabelName only matches if there is one\n            Node label = matchJumpLabelName();\n            if (label == null) {\n                if (loopSet == null || loopSet.size() == 0) {\n                    reportError(\"msg.continue.outside\");\n                    return null;\n                }\n                loop = (Node)loopSet.peek();\n            } else {\n                loop = nf.getLabelLoop(label);\n                if (loop == null) {\n                    reportError(\"msg.continue.nonloop\");\n                    return null;\n                }\n            }\n            pn = nf.createContinue(loop, lineno);\n            break;\n          }\n\n          case Token.WITH: {\n            consumeToken();\n\n            decompiler.addToken(Token.WITH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.with\");\n            decompiler.addToken(Token.LP);\n            Node obj = expr(false);\n            mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n            decompiler.addToken(Token.RP);\n            decompiler.addEOL(Token.LC);\n\n            ++nestingOfWith;\n            Node body;\n            try {\n                body = statement();\n            } finally {\n                --nestingOfWith;\n            }\n\n            decompiler.addEOL(Token.RC);\n\n            pn = nf.createWith(obj, body, lineno);\n            return pn;\n          }\n\n          case Token.VAR: {\n            consumeToken();\n            pn = variables(false);\n            break;\n          }\n\n          case Token.RETURN: {\n            if (!insideFunction()) {\n                reportError(\"msg.bad.return\");\n            }\n            consumeToken();\n            decompiler.addToken(Token.RETURN);\n            int lineno = ts.getLineno();\n\n            Node retExpr;\n            /* This is ugly, but we don't want to require a semicolon. */\n            tt = peekTokenOrEOL();\n            switch (tt) {\n              case Token.SEMI:\n              case Token.RC:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.ERROR:\n                retExpr = null;\n                break;\n              default:\n                retExpr = expr(false);\n            }\n            pn = nf.createReturn(retExpr, lineno);\n            break;\n          }\n\n          case Token.LC:\n            consumeToken();\n            if (statementLabel != null) {\n                decompiler.addToken(Token.LC);\n            }\n            pn = statements();\n            mustMatchToken(Token.RC, \"msg.no.brace.block\");\n            if (statementLabel != null) {\n                decompiler.addEOL(Token.RC);\n            }\n            return pn;\n\n          case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n          case Token.SEMI:\n            consumeToken();\n            pn = nf.createLeaf(Token.EMPTY);\n            return pn;\n\n          case Token.FUNCTION: {\n            consumeToken();\n            pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n            return pn;\n          }\n\n          case Token.DEFAULT :\n            consumeToken();\n            mustHaveXML();\n\n            decompiler.addToken(Token.DEFAULT);\n            int nsLine = ts.getLineno();\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"xml\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"namespace\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!matchToken(Token.ASSIGN)) {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addToken(Token.ASSIGN);\n\n            Node expr = expr(false);\n            pn = nf.createDefaultNamespace(expr, nsLine);\n            break;\n\n          case Token.NAME: {\n            int lineno = ts.getLineno();\n            String name = ts.getString();\n            setCheckForLabel();\n            pn = expr(false);\n            if (pn.getType() != Token.LABEL) {\n                pn = nf.createExprStatement(pn, lineno);\n            } else {\n                // Parsed the label: push back token should be\n                // colon that primaryExpr left untouched.\n                if (peekToken() != Token.COLON) Kit.codeBug();\n                consumeToken();\n                // depend on decompiling lookahead to guess that that\n                // last name was a label.\n                decompiler.addName(name);\n                decompiler.addEOL(Token.COLON);\n\n                if (labelSet == null) {\n                    labelSet = new Hashtable();\n                } else if (labelSet.containsKey(name)) {\n                    reportError(\"msg.dup.label\");\n                }\n\n                boolean firstLabel;\n                if (statementLabel == null) {\n                    firstLabel = true;\n                    statementLabel = pn;\n                } else {\n                    // Discard multiple label nodes and use only\n                    // the first: it allows to simplify IRFactory\n                    firstLabel = false;\n                }\n                labelSet.put(name, statementLabel);\n                try {\n                    pn = statementHelper(statementLabel);\n                } finally {\n                    labelSet.remove(name);\n                }\n                if (firstLabel) {\n                    pn = nf.createLabeledStatement(statementLabel, pn);\n                }\n                return pn;\n            }\n            break;\n          }\n\n          default: {\n            int lineno = ts.getLineno();\n            pn = expr(false);\n            pn = nf.createExprStatement(pn, lineno);\n            break;\n          }\n        }\n\n        int ttFlagged = peekFlaggedToken();\n        switch (ttFlagged & CLEAR_TI_MASK) {\n          case Token.SEMI:\n            // Consume ';' as a part of expression\n            consumeToken();\n            break;\n          case Token.ERROR:\n          case Token.EOF:\n          case Token.RC:\n            // Autoinsert ;\n            break;\n          default:\n            if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                // Report error if no EOL or autoinsert ; otherwise\n                reportError(\"msg.no.semi.stmt\");\n            }\n            break;\n        }\n        decompiler.addEOL(Token.SEMI);\n\n        return pn;\n    }\n\n    private Node variables(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = nf.createVariables(ts.getLineno());\n        boolean first = true;\n\n        decompiler.addToken(Token.VAR);\n\n        for (;;) {\n            Node name;\n            Node init;\n            mustMatchToken(Token.NAME, \"msg.bad.var\");\n            String s = ts.getString();\n\n            if (!first)\n                decompiler.addToken(Token.COMMA);\n            first = false;\n\n            decompiler.addName(s);\n            currentScriptOrFn.addVar(s);\n            name = nf.createName(s);\n\n            // omitted check for argument hiding\n\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n\n                init = assignExpr(inForInit);\n                nf.addChildToBack(name, init);\n            }\n            nf.addChildToBack(pn, name);\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return pn;\n    }\n\n    private Node expr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = condExpr(inForInit);\n\n        int tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node ifTrue;\n        Node ifFalse;\n\n        Node pn = orExpr(inForInit);\n\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = relExpr(inForInit);\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.EQ:\n              case Token.NE:\n              case Token.SHEQ:\n              case Token.SHNE:\n                consumeToken();\n                int decompilerToken = tt;\n                int parseToken = tt;\n                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                    // JavaScript 1.2 uses shallow equality for == and != .\n                    // In addition, convert === and !== for decompiler into\n                    // == and != since the decompiler is supposed to show\n                    // canonical source and in 1.2 ===, !== are allowed\n                    // only as an alias to ==, !=.\n                    switch (tt) {\n                      case Token.EQ:\n                        parseToken = Token.SHEQ;\n                        break;\n                      case Token.NE:\n                        parseToken = Token.SHNE;\n                        break;\n                      case Token.SHEQ:\n                        decompilerToken = Token.EQ;\n                        break;\n                      case Token.SHNE:\n                        decompilerToken = Token.NE;\n                        break;\n                    }\n                }\n                decompiler.addToken(decompilerToken);\n                pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = shiftExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.IN:\n                if (inForInit)\n                    break;\n                // fall through\n              case Token.INSTANCEOF:\n              case Token.LE:\n              case Token.LT:\n              case Token.GE:\n              case Token.GT:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, shiftExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr()\n        throws IOException, ParserException\n    {\n        Node pn = addExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.LSH:\n              case Token.URSH:\n              case Token.RSH:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, addExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr()\n        throws IOException, ParserException\n    {\n        Node pn = mulExpr();\n        for (;;) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node mulExpr()\n        throws IOException, ParserException\n    {\n        Node pn = unaryExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.MUL:\n              case Token.DIV:\n              case Token.MOD:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, unaryExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node unaryExpr()\n        throws IOException, ParserException\n    {\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.TYPEOF:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createUnary(tt, unaryExpr());\n\n        case Token.ADD:\n            consumeToken();\n            // Convert to special POS token in decompiler and parse tree\n            decompiler.addToken(Token.POS);\n            return nf.createUnary(Token.POS, unaryExpr());\n\n        case Token.SUB:\n            consumeToken();\n            // Convert to special NEG token in decompiler and parse tree\n            decompiler.addToken(Token.NEG);\n            return nf.createUnary(Token.NEG, unaryExpr());\n\n        case Token.INC:\n        case Token.DEC:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createIncDec(tt, false, memberExpr(true));\n\n        case Token.DELPROP:\n            consumeToken();\n            decompiler.addToken(Token.DELPROP);\n            return nf.createUnary(Token.DELPROP, unaryExpr());\n\n        case Token.ERROR:\n            consumeToken();\n            break;\n\n        // XML stream encountered in expression.\n        case Token.LT:\n            if (compilerEnv.isXmlAvailable()) {\n                consumeToken();\n                Node pn = xmlInitializer();\n                return memberExprTail(true, pn);\n            }\n            // Fall thru to the default handling of RELOP\n\n        default:\n            Node pn = memberExpr(true);\n\n            // Don't look across a newline boundary for a postfix incop.\n            tt = peekTokenOrEOL();\n            if (tt == Token.INC || tt == Token.DEC) {\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, true, pn);\n            }\n            return pn;\n        }\n        return nf.createName(\"err\"); // Only reached on error.  Try to continue.\n\n    }\n\n    private Node xmlInitializer() throws IOException\n    {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        decompiler.addToken(Token.NEW);\n        decompiler.addToken(Token.DOT);\n\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n\n        decompiler.addName(fAnonymous ? \"XMLList\" : \"XML\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n\n        pn = null;\n        Node expr;\n        for (;;tt = ts.getNextXMLToken()) {\n            switch (tt) {\n            case Token.XML:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                mustMatchToken(Token.LC, \"msg.syntax\");\n                decompiler.addToken(Token.LC);\n                expr = (peekToken() == Token.RC)\n                    ? nf.createString(\"\")\n                    : expr(false);\n                mustMatchToken(Token.RC, \"msg.syntax\");\n                decompiler.addToken(Token.RC);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n                int nodeType;\n                if (ts.isXMLAttribute()) {\n                    nodeType = Token.ESCXMLATTR;\n                } else {\n                    nodeType = Token.ESCXMLTEXT;\n                }\n                expr = nf.createUnary(nodeType, expr);\n                pn = nf.createBinary(Token.ADD, pn, expr);\n                break;\n            case Token.XMLEND:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n\n                nf.addChildToBack(pnXML, pn);\n                return pnXML;\n            default:\n                reportError(\"msg.syntax\");\n                return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode)\n        throws IOException, ParserException\n    {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax)\n        throws IOException, ParserException\n    {\n        int tt;\n\n        Node pn;\n\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn)\n        throws IOException, ParserException\n    {\n      tailLoop:\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n\n              case Token.DOT:\n              case Token.DOTDOT:\n                {\n                    int memberTypeFlags;\n                    String s;\n\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    memberTypeFlags = 0;\n                    if (tt == Token.DOTDOT) {\n                        mustHaveXML();\n                        memberTypeFlags = Node.DESCENDANTS_FLAG;\n                    }\n                    if (!compilerEnv.isXmlAvailable()) {\n                        mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                        break;\n                    }\n\n                    tt = nextToken();\n                    switch (tt) {\n                      // handles: name, ns::name, ns::*, ns::[expr]\n                      case Token.NAME:\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = propertyName(pn, s, memberTypeFlags);\n                        break;\n\n                      // handles: *, *::name, *::*, *::[expr]\n                      case Token.MUL:\n                        decompiler.addName(\"*\");\n                        pn = propertyName(pn, \"*\", memberTypeFlags);\n                        break;\n\n                      // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                      //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                      case Token.XMLATTR:\n                        decompiler.addToken(Token.XMLATTR);\n                        pn = attributeAccess(pn, memberTypeFlags);\n                        break;\n\n                      default:\n                        reportError(\"msg.no.name.after.dot\");\n                    }\n                }\n                break;\n\n              case Token.DOTQUERY:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DOTQUERY);\n                pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                break;\n\n              case Token.LB:\n                consumeToken();\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), 0);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n\n              case Token.LP:\n                if (!allowCallSyntax) {\n                    break tailLoop;\n                }\n                consumeToken();\n                decompiler.addToken(Token.LP);\n                pn = nf.createCallOrNew(Token.CALL, pn);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n                break;\n\n              default:\n                break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags)\n        throws IOException\n    {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n\n        switch (tt) {\n          // handles: @name, @ns::name, @ns::*, @ns::[expr]\n          case Token.NAME:\n            {\n                String s = ts.getString();\n                decompiler.addName(s);\n                pn = propertyName(pn, s, memberTypeFlags);\n            }\n            break;\n\n          // handles: @*, @*::name, @*::*, @*::[expr]\n          case Token.MUL:\n            decompiler.addName(\"*\");\n            pn = propertyName(pn, \"*\", memberTypeFlags);\n            break;\n\n          // handles @[expr]\n          case Token.LB:\n            decompiler.addToken(Token.LB);\n            pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n            mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n            decompiler.addToken(Token.RB);\n            break;\n\n          default:\n            reportError(\"msg.no.name.after.xmlAttr\");\n            pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n            break;\n        }\n\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags)\n        throws IOException, ParserException\n    {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n\n            int tt = nextToken();\n            switch (tt) {\n              // handles name::name\n              case Token.NAME:\n                name = ts.getString();\n                decompiler.addName(name);\n                break;\n\n              // handles name::*\n              case Token.MUL:\n                decompiler.addName(\"*\");\n                name = \"*\";\n                break;\n\n              // handles name::[expr]\n              case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, namespace, expr(false),\n                                         memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                return pn;\n\n              default:\n                reportError(\"msg.no.name.after.coloncolon\");\n                name = \"?\";\n            }\n        }\n\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node primaryExpr()\n        throws IOException, ParserException\n    {\n        Node pn;\n\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n\n        switch(tt) {\n\n          case Token.FUNCTION:\n            return function(FunctionNode.FUNCTION_EXPRESSION);\n\n          case Token.LB: {\n            ObjArray elems = new ObjArray();\n            int skipCount = 0;\n            decompiler.addToken(Token.LB);\n            boolean after_lb_or_comma = true;\n            for (;;) {\n                tt = peekToken();\n\n                if (tt == Token.COMMA) {\n                    consumeToken();\n                    decompiler.addToken(Token.COMMA);\n                    if (!after_lb_or_comma) {\n                        after_lb_or_comma = true;\n                    } else {\n                        elems.add(null);\n                        ++skipCount;\n                    }\n                } else if (tt == Token.RB) {\n                    consumeToken();\n                    decompiler.addToken(Token.RB);\n                    break;\n                } else {\n                    if (!after_lb_or_comma) {\n                        reportError(\"msg.no.bracket.arg\");\n                    }\n                    elems.add(assignExpr(false));\n                    after_lb_or_comma = false;\n                }\n            }\n            return nf.createArrayLiteral(elems, skipCount);\n          }\n\n          case Token.LC: {\n            ObjArray elems = new ObjArray();\n            decompiler.addToken(Token.LC);\n            if (!matchToken(Token.RC)) {\n\n                boolean first = true;\n            commaloop:\n                do {\n                    Object property;\n\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    else\n                        first = false;\n\n                    tt = peekToken();\n                    switch(tt) {\n                      case Token.NAME:\n                      case Token.STRING:\n                        consumeToken();\n                        // map NAMEs to STRINGs in object literal context\n                        // but tell the decompiler the proper type\n                        String s = ts.getString();\n                        if (tt == Token.NAME) {\n                            decompiler.addName(s);\n                        } else {\n                            decompiler.addString(s);\n                        }\n                        property = ScriptRuntime.getIndexObject(s);\n                        break;\n\n                      case Token.NUMBER:\n                        consumeToken();\n                        double n = ts.getNumber();\n                        decompiler.addNumber(n);\n                        property = ScriptRuntime.getIndexObject(n);\n                        break;\n\n                      case Token.RC:\n                        // trailing comma is OK.\n                        break commaloop;\n                    default:\n                        reportError(\"msg.bad.prop\");\n                        break commaloop;\n                    }\n                    mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n\n                    // OBJLIT is used as ':' in object literal for\n                    // decompilation to solve spacing ambiguity.\n                    decompiler.addToken(Token.OBJECTLIT);\n                    elems.add(property);\n                    elems.add(assignExpr(false));\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n            }\n            decompiler.addToken(Token.RC);\n            return nf.createObjectLiteral(elems);\n          }\n\n          case Token.LP:\n\n            /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n            decompiler.addToken(Token.LP);\n            pn = expr(false);\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.RP, \"msg.no.paren\");\n            return pn;\n\n          case Token.XMLATTR:\n            mustHaveXML();\n            decompiler.addToken(Token.XMLATTR);\n            pn = attributeAccess(null, 0);\n            return pn;\n\n          case Token.NAME: {\n            String name = ts.getString();\n            if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                if (peekToken() == Token.COLON) {\n                    // Do not consume colon, it is used as unwind indicator\n                    // to return to statementHelper.\n                    // XXX Better way?\n                    return nf.createLabel(ts.getLineno());\n                }\n            }\n\n            decompiler.addName(name);\n            if (compilerEnv.isXmlAvailable()) {\n                pn = propertyName(null, name, 0);\n            } else {\n                pn = nf.createName(name);\n            }\n            return pn;\n          }\n\n          case Token.NUMBER: {\n            double n = ts.getNumber();\n            decompiler.addNumber(n);\n            return nf.createNumber(n);\n          }\n\n          case Token.STRING: {\n            String s = ts.getString();\n            decompiler.addString(s);\n            return nf.createString(s);\n          }\n\n          case Token.DIV:\n          case Token.ASSIGN_DIV: {\n            // Got / or /= which should be treated as regexp in fact\n            ts.readRegExp(tt);\n            String flags = ts.regExpFlags;\n            ts.regExpFlags = null;\n            String re = ts.getString();\n            decompiler.addRegexp(re, flags);\n            int index = currentScriptOrFn.addRegexp(re, flags);\n            return nf.createRegExp(index);\n          }\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.FALSE:\n          case Token.TRUE:\n            decompiler.addToken(tt);\n            return nf.createLeaf(tt);\n\n          case Token.RESERVED:\n            reportError(\"msg.reserved.id\");\n            break;\n\n          case Token.ERROR:\n            /* the scanner or one of its subroutines reported the error. */\n            break;\n\n          case Token.EOF:\n            reportError(\"msg.unexpected.eof\");\n            break;\n\n          default:\n            reportError(\"msg.syntax\");\n            break;\n        }\n        return null;    // should never reach here\n    }\n\n}\n\n"
-this.functionMethodBody.toString == "private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }"
+this.sourceCode.toString == "/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n *\n * The contents of this file are subject to the Netscape Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/NPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Variant Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Variant Code is Netscape\n * Communications Corporation.  Portions created by Netscape are\n * Copyright (C) 1997-1999 Netscape Communications Corporation. All\n * Rights Reserved.\n *\n * Contributor(s):\n * Mike Ang\n * Igor Bukanov\n * Ethan Hugg\n * Terry Lucas\n * Mike McCabe\n * Milen Nankov\n *\n * Alternatively, the contents of this file may be used under the\n * terms of the GNU Public License (the \"GPL\"), in which case the\n * provisions of the GPL are applicable instead of those above.\n * If you wish to allow use of your version of this file only\n * under the terms of the GPL and not to allow others to use your\n * version of this file under the NPL, indicate your decision by\n * deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL.  If you do not delete\n * the provisions above, a recipient may use your version of this\n * file under either the NPL or the GPL.\n */\n\npackage rhino._1.VARIANT;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\nimport rhino._1.mocks.*;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\n\npublic class Parser\n{\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int\n        CLEAR_TI_MASK  = 0xFFFF,   // mask to clear token information bits\n        TI_AFTER_EOL   = 1 << 16,  // first token of the source line\n        TI_CHECK_LABEL = 1 << 17;  // indicates to check for label\n\n    CompilerEnvirons compilerEnv;\n    private ErrorReporter errorReporter;\n    private String sourceURI;\n\n    private TokenStream ts;\n    private int currentFlaggedToken;\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n    private String encodedSource;\n\n// The following are per function variables and should be saved/restored\n// during function parsing.\n// XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n    private int nestingOfWith;\n    private Hashtable labelSet; // map of label names into nodes\n    private ObjArray loopSet;\n    private ObjArray loopAndSwitchSet;\n// end of per function variables\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException\n    {\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter)\n    {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv)\n    {\n        return new Decompiler();\n    }\n\n    void addWarning(String messageId, String messageArg)\n    {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.warning(message, sourceURI, ts.getLineno(),\n                              ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId)\n    {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(),\n                            ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId)\n    {\n        addError(messageId);\n\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken()\n        throws IOException\n    {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken()\n    {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken()\n        throws IOException\n    {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch)\n        throws IOException\n    {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL()\n        throws IOException\n    {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel()\n    {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId)\n        throws IOException, ParserException\n    {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML()\n    {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource()\n    {\n        return encodedSource;\n    }\n\n    public boolean eof()\n    {\n        return ts.eof();\n    }\n\n    boolean insideFunction()\n    {\n        return nestingOfFunction != 0;\n    }\n\n    private Node enterLoop(Node loopLabel)\n    {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        return loop;\n    }\n\n    private void exitLoop()\n    {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel)\n    {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch()\n    {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString,\n                                String sourceURI, int lineno)\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader,\n                                String sourceURI, int lineno)\n        throws IOException\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse()\n        throws IOException\n    {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n\n        try {\n            for (;;) {\n                int tt = peekToken();\n\n                if (tt <= Token.EOF) {\n                    break;\n                }\n\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\n                \"mag.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI,\n                                             ts.getLineno(), null, 0);\n        }\n\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno,\n                                             null, 0);\n        }\n\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset,\n                                                 sourceEndOffset);\n\n        nf.initScript(currentScriptOrFn, pn);\n\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        this.decompiler = null; // It helps GC\n\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody()\n        throws IOException\n    {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (;;) {\n                Node n;\n                int tt = peekToken();\n                switch (tt) {\n                  case Token.ERROR:\n                  case Token.EOF:\n                  case Token.RC:\n                    break bodyLoop;\n\n                  case Token.FUNCTION:\n                    consumeToken();\n                    n = function(FunctionNode.FUNCTION_STATEMENT);\n                    break;\n                  default:\n                    n = statement();\n                    break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n\n        return pn;\n    }\n\n    private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements()\n        throws IOException\n    {\n        Node pn = nf.createBlock(ts.getLineno());\n\n        int tt;\n        while((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n\n        return pn;\n    }\n\n    private Node condition()\n        throws IOException, ParserException\n    {\n        Node pn;\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n\n        // there's a check here in jsparse.c that corrects = to ==\n\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName()\n        throws IOException, ParserException\n    {\n        Node label = null;\n\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = (Node)labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n\n        return label;\n    }\n\n    private Node statement()\n        throws IOException\n    {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                return pn;\n            }\n        } catch (ParserException e) { }\n\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (;;) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch (tt) {\n              case Token.ERROR:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.SEMI:\n                break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    /**\n     * Whether the \"catch (e: e instanceof Exception) { ... }\" syntax\n     * is implemented.\n     */\n\n    private Node statementHelper(Node statementLabel)\n        throws IOException, ParserException\n    {\n        Node pn = null;\n\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n          case Token.IF: {\n            consumeToken();\n\n            decompiler.addToken(Token.IF);\n            int lineno = ts.getLineno();\n            Node cond = condition();\n            decompiler.addEOL(Token.LC);\n            Node ifTrue = statement();\n            Node ifFalse = null;\n            if (matchToken(Token.ELSE)) {\n                decompiler.addToken(Token.RC);\n                decompiler.addToken(Token.ELSE);\n                decompiler.addEOL(Token.LC);\n                ifFalse = statement();\n            }\n            decompiler.addEOL(Token.RC);\n            pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n            return pn;\n          }\n\n          case Token.SWITCH: {\n            consumeToken();\n\n            decompiler.addToken(Token.SWITCH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n            decompiler.addToken(Token.LP);\n            pn = enterSwitch(expr(false), lineno, statementLabel);\n            try {\n                mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                decompiler.addEOL(Token.LC);\n\n                boolean hasDefault = false;\n                switchLoop: for (;;) {\n                    tt = nextToken();\n                    Node caseExpression;\n                    switch (tt) {\n                      case Token.RC:\n                        break switchLoop;\n\n                      case Token.CASE:\n                        decompiler.addToken(Token.CASE);\n                        caseExpression = expr(false);\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      case Token.DEFAULT:\n                        if (hasDefault) {\n                            reportError(\"msg.double.switch.default\");\n                        }\n                        decompiler.addToken(Token.DEFAULT);\n                        hasDefault = true;\n                        caseExpression = null;\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      default:\n                        reportError(\"msg.bad.switch\");\n                        break switchLoop;\n                    }\n\n                    Node block = nf.createLeaf(Token.BLOCK);\n                    while ((tt = peekToken()) != Token.RC\n                           && tt != Token.CASE\n                           && tt != Token.DEFAULT\n                           && tt != Token.EOF)\n                    {\n                        nf.addChildToBack(block, statement());\n                    }\n\n                    // caseExpression == null => add default lable\n                    nf.addSwitchCase(pn, caseExpression, block);\n                }\n                decompiler.addEOL(Token.RC);\n                nf.closeSwitch(pn);\n            } finally {\n                exitSwitch();\n            }\n            return pn;\n          }\n\n          case Token.WHILE: {\n            consumeToken();\n            decompiler.addToken(Token.WHILE);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node cond = condition();\n                decompiler.addEOL(Token.LC);\n                Node body = statement();\n                decompiler.addEOL(Token.RC);\n                pn = nf.createWhile(loop, cond, body);\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.DO: {\n            consumeToken();\n            decompiler.addToken(Token.DO);\n            decompiler.addEOL(Token.LC);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node body = statement();\n                decompiler.addToken(Token.RC);\n                mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                decompiler.addToken(Token.WHILE);\n                Node cond = condition();\n                pn = nf.createDoWhile(loop, body, cond);\n            } finally {\n                exitLoop();\n            }\n            // Always auto-insert semicon to follow SpiderMonkey:\n            // It is required by EMAScript but is ignored by the rest of\n            // world, see bug 238945\n            matchToken(Token.SEMI);\n            decompiler.addEOL(Token.SEMI);\n            return pn;\n          }\n\n          case Token.FOR: {\n            consumeToken();\n            boolean isForEach = false;\n            decompiler.addToken(Token.FOR);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n\n                Node init;  // Node init is also foo in 'foo in Object'\n                Node cond;  // Node cond is also object in 'foo in Object'\n                Node incr = null; // to kill warning\n                Node body;\n\n                // See if this is a for each () instead of just a for ()\n                if (matchToken(Token.NAME)) {\n                    decompiler.addName(ts.getString());\n                    if (ts.getString().equals(\"each\")) {\n                        isForEach = true;\n                    } else {\n                        reportError(\"msg.no.paren.for\");\n                    }\n                }\n\n                mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                decompiler.addToken(Token.LP);\n                tt = peekToken();\n                if (tt == Token.SEMI) {\n                    init = nf.createLeaf(Token.EMPTY);\n                } else {\n                    if (tt == Token.VAR) {\n                        // set init to a var list or initial\n                        consumeToken();    // consume the 'var' token\n                        init = variables(true);\n                    }\n                    else {\n                        init = expr(true);\n                    }\n                }\n\n                if (matchToken(Token.IN)) {\n                    decompiler.addToken(Token.IN);\n                    // 'cond' is the object over which we're iterating\n                    cond = expr(false);\n                } else {  // ordinary for loop\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.SEMI) {\n                        // no loop condition\n                        cond = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        cond = expr(false);\n                    }\n\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.RP) {\n                        incr = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        incr = expr(false);\n                    }\n                }\n\n                mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                decompiler.addToken(Token.RP);\n                decompiler.addEOL(Token.LC);\n                body = statement();\n                decompiler.addEOL(Token.RC);\n\n                if (incr == null) {\n                    // cond could be null if 'in obj' got eaten\n                    // by the init node.\n                    pn = nf.createForIn(loop, init, cond, body, isForEach);\n                } else {\n                    pn = nf.createFor(loop, init, cond, incr, body);\n                }\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.TRY: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            Node tryblock;\n            Node catchblocks = null;\n            Node finallyblock = null;\n\n            decompiler.addToken(Token.TRY);\n            decompiler.addEOL(Token.LC);\n            tryblock = statement();\n            decompiler.addEOL(Token.RC);\n\n            catchblocks = nf.createLeaf(Token.BLOCK);\n\n            boolean sawDefaultCatch = false;\n            int peek = peekToken();\n            if (peek == Token.CATCH) {\n                while (matchToken(Token.CATCH)) {\n                    if (sawDefaultCatch) {\n                        reportError(\"msg.catch.unreachable\");\n                    }\n                    decompiler.addToken(Token.CATCH);\n                    mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                    decompiler.addToken(Token.LP);\n\n                    mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                    String varName = ts.getString();\n                    decompiler.addName(varName);\n\n                    Node catchCond = null;\n                    if (matchToken(Token.IF)) {\n                        decompiler.addToken(Token.IF);\n                        catchCond = expr(false);\n                    } else {\n                        sawDefaultCatch = true;\n                    }\n\n                    mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                    decompiler.addToken(Token.RP);\n                    mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                    decompiler.addEOL(Token.LC);\n\n                    nf.addChildToBack(catchblocks,\n                        nf.createCatch(varName, catchCond,\n                                       statements(),\n                                       ts.getLineno()));\n\n                    mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                    decompiler.addEOL(Token.RC);\n                }\n            } else if (peek != Token.FINALLY) {\n                mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n            }\n\n            if (matchToken(Token.FINALLY)) {\n                decompiler.addToken(Token.FINALLY);\n                decompiler.addEOL(Token.LC);\n                finallyblock = statement();\n                decompiler.addEOL(Token.RC);\n            }\n\n            pn = nf.createTryCatchFinally(tryblock, catchblocks,\n                                          finallyblock, lineno);\n\n            return pn;\n          }\n\n          case Token.THROW: {\n            consumeToken();\n            if (peekTokenOrEOL() == Token.EOL) {\n                // ECMAScript does not allow new lines before throw expression,\n                // see bug 256617\n                reportError(\"msg.bad.throw.eol\");\n            }\n\n            int lineno = ts.getLineno();\n            decompiler.addToken(Token.THROW);\n            pn = nf.createThrow(expr(false), lineno);\n            break;\n          }\n\n          case Token.BREAK: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.BREAK);\n\n            // matchJumpLabelName only matches if there is one\n            Node breakStatement = matchJumpLabelName();\n            if (breakStatement == null) {\n                if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                    reportError(\"msg.bad.break\");\n                    return null;\n                }\n                breakStatement = (Node)loopAndSwitchSet.peek();\n            }\n            pn = nf.createBreak(breakStatement, lineno);\n            break;\n          }\n\n          case Token.CONTINUE: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.CONTINUE);\n\n            Node loop;\n            // matchJumpLabelName only matches if there is one\n            Node label = matchJumpLabelName();\n            if (label == null) {\n                if (loopSet == null || loopSet.size() == 0) {\n                    reportError(\"msg.continue.outside\");\n                    return null;\n                }\n                loop = (Node)loopSet.peek();\n            } else {\n                loop = nf.getLabelLoop(label);\n                if (loop == null) {\n                    reportError(\"msg.continue.nonloop\");\n                    return null;\n                }\n            }\n            pn = nf.createContinue(loop, lineno);\n            break;\n          }\n\n          case Token.WITH: {\n            consumeToken();\n\n            decompiler.addToken(Token.WITH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.with\");\n            decompiler.addToken(Token.LP);\n            Node obj = expr(false);\n            mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n            decompiler.addToken(Token.RP);\n            decompiler.addEOL(Token.LC);\n\n            ++nestingOfWith;\n            Node body;\n            try {\n                body = statement();\n            } finally {\n                --nestingOfWith;\n            }\n\n            decompiler.addEOL(Token.RC);\n\n            pn = nf.createWith(obj, body, lineno);\n            return pn;\n          }\n\n          case Token.VAR: {\n            consumeToken();\n            pn = variables(false);\n            break;\n          }\n\n          case Token.RETURN: {\n            if (!insideFunction()) {\n                reportError(\"msg.bad.return\");\n            }\n            consumeToken();\n            decompiler.addToken(Token.RETURN);\n            int lineno = ts.getLineno();\n\n            Node retExpr;\n            /* This is ugly, but we don't want to require a semicolon. */\n            tt = peekTokenOrEOL();\n            switch (tt) {\n              case Token.SEMI:\n              case Token.RC:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.ERROR:\n                retExpr = null;\n                break;\n              default:\n                retExpr = expr(false);\n            }\n            pn = nf.createReturn(retExpr, lineno);\n            break;\n          }\n\n          case Token.LC:\n            consumeToken();\n            if (statementLabel != null) {\n                decompiler.addToken(Token.LC);\n            }\n            pn = statements();\n            mustMatchToken(Token.RC, \"msg.no.brace.block\");\n            if (statementLabel != null) {\n                decompiler.addEOL(Token.RC);\n            }\n            return pn;\n\n          case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n          case Token.SEMI:\n            consumeToken();\n            pn = nf.createLeaf(Token.EMPTY);\n            return pn;\n\n          case Token.FUNCTION: {\n            consumeToken();\n            pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n            return pn;\n          }\n\n          case Token.DEFAULT :\n            consumeToken();\n            mustHaveXML();\n\n            decompiler.addToken(Token.DEFAULT);\n            int nsLine = ts.getLineno();\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"xml\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"namespace\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!matchToken(Token.ASSIGN)) {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addToken(Token.ASSIGN);\n\n            Node expr = expr(false);\n            pn = nf.createDefaultNamespace(expr, nsLine);\n            break;\n\n          case Token.NAME: {\n            int lineno = ts.getLineno();\n            String name = ts.getString();\n            setCheckForLabel();\n            pn = expr(false);\n            if (pn.getType() != Token.LABEL) {\n                pn = nf.createExprStatement(pn, lineno);\n            } else {\n                // Parsed the label: push back token should be\n                // colon that primaryExpr left untouched.\n                if (peekToken() != Token.COLON) Kit.codeBug();\n                consumeToken();\n                // depend on decompiling lookahead to guess that that\n                // last name was a label.\n                decompiler.addName(name);\n                decompiler.addEOL(Token.COLON);\n\n                if (labelSet == null) {\n                    labelSet = new Hashtable();\n                } else if (labelSet.containsKey(name)) {\n                    reportError(\"msg.dup.label\");\n                }\n\n                boolean firstLabel;\n                if (statementLabel == null) {\n                    firstLabel = true;\n                    statementLabel = pn;\n                } else {\n                    // Discard multiple label nodes and use only\n                    // the first: it allows to simplify IRFactory\n                    firstLabel = false;\n                }\n                labelSet.put(name, statementLabel);\n                try {\n                    pn = statementHelper(statementLabel);\n                } finally {\n                    labelSet.remove(name);\n                }\n                if (firstLabel) {\n                    pn = nf.createLabeledStatement(statementLabel, pn);\n                }\n                return pn;\n            }\n            break;\n          }\n\n          default: {\n            int lineno = ts.getLineno();\n            pn = expr(false);\n            pn = nf.createExprStatement(pn, lineno);\n            break;\n          }\n        }\n\n        int ttFlagged = peekFlaggedToken();\n        switch (ttFlagged & CLEAR_TI_MASK) {\n          case Token.SEMI:\n            // Consume ';' as a part of expression\n            consumeToken();\n            break;\n          case Token.ERROR:\n          case Token.EOF:\n          case Token.RC:\n            // Autoinsert ;\n            break;\n          default:\n            if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                // Report error if no EOL or autoinsert ; otherwise\n                reportError(\"msg.no.semi.stmt\");\n            }\n            break;\n        }\n        decompiler.addEOL(Token.SEMI);\n\n        return pn;\n    }\n\n    private Node variables(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = nf.createVariables(ts.getLineno());\n        boolean first = true;\n\n        decompiler.addToken(Token.VAR);\n\n        for (;;) {\n            Node name;\n            Node init;\n            mustMatchToken(Token.NAME, \"msg.bad.var\");\n            String s = ts.getString();\n\n            if (!first)\n                decompiler.addToken(Token.COMMA);\n            first = false;\n\n            decompiler.addName(s);\n            currentScriptOrFn.addVar(s);\n            name = nf.createName(s);\n\n            // omitted check for argument hiding\n\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n\n                init = assignExpr(inForInit);\n                nf.addChildToBack(name, init);\n            }\n            nf.addChildToBack(pn, name);\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return pn;\n    }\n\n    private Node expr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = condExpr(inForInit);\n\n        int tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node ifTrue;\n        Node ifFalse;\n\n        Node pn = orExpr(inForInit);\n\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = relExpr(inForInit);\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.EQ:\n              case Token.NE:\n              case Token.SHEQ:\n              case Token.SHNE:\n                consumeToken();\n                int decompilerToken = tt;\n                int parseToken = tt;\n                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                    // JavaScript 1.2 uses shallow equality for == and != .\n                    // In addition, convert === and !== for decompiler into\n                    // == and != since the decompiler is supposed to show\n                    // canonical source and in 1.2 ===, !== are allowed\n                    // only as an alias to ==, !=.\n                    switch (tt) {\n                      case Token.EQ:\n                        parseToken = Token.SHEQ;\n                        break;\n                      case Token.NE:\n                        parseToken = Token.SHNE;\n                        break;\n                      case Token.SHEQ:\n                        decompilerToken = Token.EQ;\n                        break;\n                      case Token.SHNE:\n                        decompilerToken = Token.NE;\n                        break;\n                    }\n                }\n                decompiler.addToken(decompilerToken);\n                pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = shiftExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.IN:\n                if (inForInit)\n                    break;\n                // fall through\n              case Token.INSTANCEOF:\n              case Token.LE:\n              case Token.LT:\n              case Token.GE:\n              case Token.GT:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, shiftExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr()\n        throws IOException, ParserException\n    {\n        Node pn = addExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.LSH:\n              case Token.URSH:\n              case Token.RSH:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, addExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr()\n        throws IOException, ParserException\n    {\n        Node pn = mulExpr();\n        for (;;) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node mulExpr()\n        throws IOException, ParserException\n    {\n        Node pn = unaryExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.MUL:\n              case Token.DIV:\n              case Token.MOD:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, unaryExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node unaryExpr()\n        throws IOException, ParserException\n    {\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.TYPEOF:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createUnary(tt, unaryExpr());\n\n        case Token.ADD:\n            consumeToken();\n            // Convert to special POS token in decompiler and parse tree\n            decompiler.addToken(Token.POS);\n            return nf.createUnary(Token.POS, unaryExpr());\n\n        case Token.SUB:\n            consumeToken();\n            // Convert to special NEG token in decompiler and parse tree\n            decompiler.addToken(Token.NEG);\n            return nf.createUnary(Token.NEG, unaryExpr());\n\n        case Token.INC:\n        case Token.DEC:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createIncDec(tt, false, memberExpr(true));\n\n        case Token.DELPROP:\n            consumeToken();\n            decompiler.addToken(Token.DELPROP);\n            return nf.createUnary(Token.DELPROP, unaryExpr());\n\n        case Token.ERROR:\n            consumeToken();\n            break;\n\n        // XML stream encountered in expression.\n        case Token.LT:\n            if (compilerEnv.isXmlAvailable()) {\n                consumeToken();\n                Node pn = xmlInitializer();\n                return memberExprTail(true, pn);\n            }\n            // Fall thru to the default handling of RELOP\n\n        default:\n            Node pn = memberExpr(true);\n\n            // Don't look across a newline boundary for a postfix incop.\n            tt = peekTokenOrEOL();\n            if (tt == Token.INC || tt == Token.DEC) {\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, true, pn);\n            }\n            return pn;\n        }\n        return nf.createName(\"err\"); // Only reached on error.  Try to continue.\n\n    }\n\n    private Node xmlInitializer() throws IOException\n    {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        decompiler.addToken(Token.NEW);\n        decompiler.addToken(Token.DOT);\n\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n\n        decompiler.addName(fAnonymous ? \"XMLList\" : \"XML\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n\n        pn = null;\n        Node expr;\n        for (;;tt = ts.getNextXMLToken()) {\n            switch (tt) {\n            case Token.XML:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                mustMatchToken(Token.LC, \"msg.syntax\");\n                decompiler.addToken(Token.LC);\n                expr = (peekToken() == Token.RC)\n                    ? nf.createString(\"\")\n                    : expr(false);\n                mustMatchToken(Token.RC, \"msg.syntax\");\n                decompiler.addToken(Token.RC);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n                int nodeType;\n                if (ts.isXMLAttribute()) {\n                    nodeType = Token.ESCXMLATTR;\n                } else {\n                    nodeType = Token.ESCXMLTEXT;\n                }\n                expr = nf.createUnary(nodeType, expr);\n                pn = nf.createBinary(Token.ADD, pn, expr);\n                break;\n            case Token.XMLEND:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n\n                nf.addChildToBack(pnXML, pn);\n                return pnXML;\n            default:\n                reportError(\"msg.syntax\");\n                return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode)\n        throws IOException, ParserException\n    {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax)\n        throws IOException, ParserException\n    {\n        int tt;\n\n        Node pn;\n\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn)\n        throws IOException, ParserException\n    {\n      tailLoop:\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n\n              case Token.DOT:\n              case Token.DOTDOT:\n                {\n                    int memberTypeFlags;\n                    String s;\n\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    memberTypeFlags = 0;\n                    if (tt == Token.DOTDOT) {\n                        mustHaveXML();\n                        memberTypeFlags = Node.DESCENDANTS_FLAG;\n                    }\n                    if (!compilerEnv.isXmlAvailable()) {\n                        mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                        break;\n                    }\n\n                    tt = nextToken();\n                    switch (tt) {\n                      // handles: name, ns::name, ns::*, ns::[expr]\n                      case Token.NAME:\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = propertyName(pn, s, memberTypeFlags);\n                        break;\n\n                      // handles: *, *::name, *::*, *::[expr]\n                      case Token.MUL:\n                        decompiler.addName(\"*\");\n                        pn = propertyName(pn, \"*\", memberTypeFlags);\n                        break;\n\n                      // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                      //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                      case Token.XMLATTR:\n                        decompiler.addToken(Token.XMLATTR);\n                        pn = attributeAccess(pn, memberTypeFlags);\n                        break;\n\n                      default:\n                        reportError(\"msg.no.name.after.dot\");\n                    }\n                }\n                break;\n\n              case Token.DOTQUERY:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DOTQUERY);\n                pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                break;\n\n              case Token.LB:\n                consumeToken();\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), 0);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n\n              case Token.LP:\n                if (!allowCallSyntax) {\n                    break tailLoop;\n                }\n                consumeToken();\n                decompiler.addToken(Token.LP);\n                pn = nf.createCallOrNew(Token.CALL, pn);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n                break;\n\n              default:\n                break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags)\n        throws IOException\n    {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n\n        switch (tt) {\n          // handles: @name, @ns::name, @ns::*, @ns::[expr]\n          case Token.NAME:\n            {\n                String s = ts.getString();\n                decompiler.addName(s);\n                pn = propertyName(pn, s, memberTypeFlags);\n            }\n            break;\n\n          // handles: @*, @*::name, @*::*, @*::[expr]\n          case Token.MUL:\n            decompiler.addName(\"*\");\n            pn = propertyName(pn, \"*\", memberTypeFlags);\n            break;\n\n          // handles @[expr]\n          case Token.LB:\n            decompiler.addToken(Token.LB);\n            pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n            mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n            decompiler.addToken(Token.RB);\n            break;\n\n          default:\n            reportError(\"msg.no.name.after.xmlAttr\");\n            pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n            break;\n        }\n\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags)\n        throws IOException, ParserException\n    {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n\n            int tt = nextToken();\n            switch (tt) {\n              // handles name::name\n              case Token.NAME:\n                name = ts.getString();\n                decompiler.addName(name);\n                break;\n\n              // handles name::*\n              case Token.MUL:\n                decompiler.addName(\"*\");\n                name = \"*\";\n                break;\n\n              // handles name::[expr]\n              case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, namespace, expr(false),\n                                         memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                return pn;\n\n              default:\n                reportError(\"msg.no.name.after.coloncolon\");\n                name = \"?\";\n            }\n        }\n\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node primaryExpr()\n        throws IOException, ParserException\n    {\n        Node pn;\n\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n\n        switch(tt) {\n\n          case Token.FUNCTION:\n            return function(FunctionNode.FUNCTION_EXPRESSION);\n\n          case Token.LB: {\n            ObjArray elems = new ObjArray();\n            int skipCount = 0;\n            decompiler.addToken(Token.LB);\n            boolean after_lb_or_comma = true;\n            for (;;) {\n                tt = peekToken();\n\n                if (tt == Token.COMMA) {\n                    consumeToken();\n                    decompiler.addToken(Token.COMMA);\n                    if (!after_lb_or_comma) {\n                        after_lb_or_comma = true;\n                    } else {\n                        elems.add(null);\n                        ++skipCount;\n                    }\n                } else if (tt == Token.RB) {\n                    consumeToken();\n                    decompiler.addToken(Token.RB);\n                    break;\n                } else {\n                    if (!after_lb_or_comma) {\n                        reportError(\"msg.no.bracket.arg\");\n                    }\n                    elems.add(assignExpr(false));\n                    after_lb_or_comma = false;\n                }\n            }\n            return nf.createArrayLiteral(elems, skipCount);\n          }\n\n          case Token.LC: {\n            ObjArray elems = new ObjArray();\n            decompiler.addToken(Token.LC);\n            if (!matchToken(Token.RC)) {\n\n                boolean first = true;\n            commaloop:\n                do {\n                    Object property;\n\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    else\n                        first = false;\n\n                    tt = peekToken();\n                    switch(tt) {\n                      case Token.NAME:\n                      case Token.STRING:\n                        consumeToken();\n                        // map NAMEs to STRINGs in object literal context\n                        // but tell the decompiler the proper type\n                        String s = ts.getString();\n                        if (tt == Token.NAME) {\n                            decompiler.addName(s);\n                        } else {\n                            decompiler.addString(s);\n                        }\n                        property = ScriptRuntime.getIndexObject(s);\n                        break;\n\n                      case Token.NUMBER:\n                        consumeToken();\n                        double n = ts.getNumber();\n                        decompiler.addNumber(n);\n                        property = ScriptRuntime.getIndexObject(n);\n                        break;\n\n                      case Token.RC:\n                        // trailing comma is OK.\n                        break commaloop;\n                    default:\n                        reportError(\"msg.bad.prop\");\n                        break commaloop;\n                    }\n                    mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n\n                    // OBJLIT is used as ':' in object literal for\n                    // decompilation to solve spacing ambiguity.\n                    decompiler.addToken(Token.OBJECTLIT);\n                    elems.add(property);\n                    elems.add(assignExpr(false));\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n            }\n            decompiler.addToken(Token.RC);\n            return nf.createObjectLiteral(elems);\n          }\n\n          case Token.LP:\n\n            /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n            decompiler.addToken(Token.LP);\n            pn = expr(false);\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.RP, \"msg.no.paren\");\n            return pn;\n\n          case Token.XMLATTR:\n            mustHaveXML();\n            decompiler.addToken(Token.XMLATTR);\n            pn = attributeAccess(null, 0);\n            return pn;\n\n          case Token.NAME: {\n            String name = ts.getString();\n            if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                if (peekToken() == Token.COLON) {\n                    // Do not consume colon, it is used as unwind indicator\n                    // to return to statementHelper.\n                    // XXX Better way?\n                    return nf.createLabel(ts.getLineno());\n                }\n            }\n\n            decompiler.addName(name);\n            if (compilerEnv.isXmlAvailable()) {\n                pn = propertyName(null, name, 0);\n            } else {\n                pn = nf.createName(name);\n            }\n            return pn;\n          }\n\n          case Token.NUMBER: {\n            double n = ts.getNumber();\n            decompiler.addNumber(n);\n            return nf.createNumber(n);\n          }\n\n          case Token.STRING: {\n            String s = ts.getString();\n            decompiler.addString(s);\n            return nf.createString(s);\n          }\n\n          case Token.DIV:\n          case Token.ASSIGN_DIV: {\n            // Got / or /= which should be treated as regexp in fact\n            ts.readRegExp(tt);\n            String flags = ts.regExpFlags;\n            ts.regExpFlags = null;\n            String re = ts.getString();\n            decompiler.addRegexp(re, flags);\n            int index = currentScriptOrFn.addRegexp(re, flags);\n            return nf.createRegExp(index);\n          }\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.FALSE:\n          case Token.TRUE:\n            decompiler.addToken(tt);\n            return nf.createLeaf(tt);\n\n          case Token.RESERVED:\n            reportError(\"msg.reserved.id\");\n            break;\n\n          case Token.ERROR:\n            /* the scanner or one of its subroutines reported the error. */\n            break;\n\n          case Token.EOF:\n            reportError(\"msg.unexpected.eof\");\n            break;\n\n          default:\n            reportError(\"msg.syntax\");\n            break;\n        }\n        return null;    // should never reach here\n    }\n\n}"
+this.functionMethodBody.toString == "private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }"
 this.variant.toString > this.sourceCode.toString
 this.variant.toString < this.functionMethodBody.toString
 this.sourceCode.toString < this.functionMethodBody.toString
@@ -82,7 +87,7 @@
 this.parser has only one value
 this.sourceCode has only one value
 this.functionMethodBody has only one value
-return == 2
+return == 1
 ===========================================================================
 rhino._1.Driver.extractFunctionMethod(java.lang.String):::ENTER
 this.sourceCode == source
@@ -104,8 +109,8 @@
 source.toString == orig(this.sourceCode.toString)
 source.toString == orig(source.toString)
 this.functionMethodBody == null
-source.toString == "/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n *\n * The contents of this file are subject to the Netscape Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/NPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Variant Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Variant Code is Netscape\n * Communications Corporation.  Portions created by Netscape are\n * Copyright (C) 1997-1999 Netscape Communications Corporation. All\n * Rights Reserved.\n *\n * Contributor(s):\n * Mike Ang\n * Igor Bukanov\n * Ethan Hugg\n * Terry Lucas\n * Mike McCabe\n * Milen Nankov\n *\n * Alternatively, the contents of this file may be used under the\n * terms of the GNU Public License (the \"GPL\"), in which case the\n * provisions of the GPL are applicable instead of those above.\n * If you wish to allow use of your version of this file only\n * under the terms of the GPL and not to allow others to use your\n * version of this file under the NPL, indicate your decision by\n * deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL.  If you do not delete\n * the provisions above, a recipient may use your version of this\n * file under either the NPL or the GPL.\n */\n\npackage rhino._1.VARIANT;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\nimport rhino._1.mocks.*;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\n\npublic class Parser\n{\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int\n        CLEAR_TI_MASK  = 0xFFFF,   // mask to clear token information bits\n        TI_AFTER_EOL   = 1 << 16,  // first token of the source line\n        TI_CHECK_LABEL = 1 << 17;  // indicates to check for label\n\n    CompilerEnvirons compilerEnv;\n    private ErrorReporter errorReporter;\n    private String sourceURI;\n\n    private TokenStream ts;\n    private int currentFlaggedToken;\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n    private String encodedSource;\n\n// The following are per function variables and should be saved/restored\n// during function parsing.\n// XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n    private int nestingOfWith;\n    private Hashtable labelSet; // map of label names into nodes\n    private ObjArray loopSet;\n    private ObjArray loopAndSwitchSet;\n// end of per function variables\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException\n    {\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter)\n    {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv)\n    {\n        return new Decompiler();\n    }\n\n    void addWarning(String messageId, String messageArg)\n    {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.warning(message, sourceURI, ts.getLineno(),\n                              ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId)\n    {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(),\n                            ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId)\n    {\n        addError(messageId);\n\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken()\n        throws IOException\n    {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken()\n    {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken()\n        throws IOException\n    {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch)\n        throws IOException\n    {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL()\n        throws IOException\n    {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel()\n    {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId)\n        throws IOException, ParserException\n    {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML()\n    {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource()\n    {\n        return encodedSource;\n    }\n\n    public boolean eof()\n    {\n        return ts.eof();\n    }\n\n    boolean insideFunction()\n    {\n        return nestingOfFunction != 0;\n    }\n\n    private Node enterLoop(Node loopLabel)\n    {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        return loop;\n    }\n\n    private void exitLoop()\n    {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel)\n    {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch()\n    {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString,\n                                String sourceURI, int lineno)\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader,\n                                String sourceURI, int lineno)\n        throws IOException\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse()\n        throws IOException\n    {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n\n        try {\n            for (;;) {\n                int tt = peekToken();\n\n                if (tt <= Token.EOF) {\n                    break;\n                }\n\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\n                \"mag.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI,\n                                             ts.getLineno(), null, 0);\n        }\n\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno,\n                                             null, 0);\n        }\n\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset,\n                                                 sourceEndOffset);\n\n        nf.initScript(currentScriptOrFn, pn);\n\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        this.decompiler = null; // It helps GC\n\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody()\n        throws IOException\n    {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (;;) {\n                Node n;\n                int tt = peekToken();\n                switch (tt) {\n                  case Token.ERROR:\n                  case Token.EOF:\n                  case Token.RC:\n                    break bodyLoop;\n\n                  case Token.FUNCTION:\n                    consumeToken();\n                    n = function(FunctionNode.FUNCTION_STATEMENT);\n                    break;\n                  default:\n                    n = statement();\n                    break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n\n        return pn;\n    }\n\n    private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements()\n        throws IOException\n    {\n        Node pn = nf.createBlock(ts.getLineno());\n\n        int tt;\n        while((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n\n        return pn;\n    }\n\n    private Node condition()\n        throws IOException, ParserException\n    {\n        Node pn;\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n\n        // there's a check here in jsparse.c that corrects = to ==\n\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName()\n        throws IOException, ParserException\n    {\n        Node label = null;\n\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = (Node)labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n\n        return label;\n    }\n\n    private Node statement()\n        throws IOException\n    {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                return pn;\n            }\n        } catch (ParserException e) { }\n\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (;;) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch (tt) {\n              case Token.ERROR:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.SEMI:\n                break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    /**\n     * Whether the \"catch (e: e instanceof Exception) { ... }\" syntax\n     * is implemented.\n     */\n\n    private Node statementHelper(Node statementLabel)\n        throws IOException, ParserException\n    {\n        Node pn = null;\n\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n          case Token.IF: {\n            consumeToken();\n\n            decompiler.addToken(Token.IF);\n            int lineno = ts.getLineno();\n            Node cond = condition();\n            decompiler.addEOL(Token.LC);\n            Node ifTrue = statement();\n            Node ifFalse = null;\n            if (matchToken(Token.ELSE)) {\n                decompiler.addToken(Token.RC);\n                decompiler.addToken(Token.ELSE);\n                decompiler.addEOL(Token.LC);\n                ifFalse = statement();\n            }\n            decompiler.addEOL(Token.RC);\n            pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n            return pn;\n          }\n\n          case Token.SWITCH: {\n            consumeToken();\n\n            decompiler.addToken(Token.SWITCH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n            decompiler.addToken(Token.LP);\n            pn = enterSwitch(expr(false), lineno, statementLabel);\n            try {\n                mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                decompiler.addEOL(Token.LC);\n\n                boolean hasDefault = false;\n                switchLoop: for (;;) {\n                    tt = nextToken();\n                    Node caseExpression;\n                    switch (tt) {\n                      case Token.RC:\n                        break switchLoop;\n\n                      case Token.CASE:\n                        decompiler.addToken(Token.CASE);\n                        caseExpression = expr(false);\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      case Token.DEFAULT:\n                        if (hasDefault) {\n                            reportError(\"msg.double.switch.default\");\n                        }\n                        decompiler.addToken(Token.DEFAULT);\n                        hasDefault = true;\n                        caseExpression = null;\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      default:\n                        reportError(\"msg.bad.switch\");\n                        break switchLoop;\n                    }\n\n                    Node block = nf.createLeaf(Token.BLOCK);\n                    while ((tt = peekToken()) != Token.RC\n                           && tt != Token.CASE\n                           && tt != Token.DEFAULT\n                           && tt != Token.EOF)\n                    {\n                        nf.addChildToBack(block, statement());\n                    }\n\n                    // caseExpression == null => add default lable\n                    nf.addSwitchCase(pn, caseExpression, block);\n                }\n                decompiler.addEOL(Token.RC);\n                nf.closeSwitch(pn);\n            } finally {\n                exitSwitch();\n            }\n            return pn;\n          }\n\n          case Token.WHILE: {\n            consumeToken();\n            decompiler.addToken(Token.WHILE);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node cond = condition();\n                decompiler.addEOL(Token.LC);\n                Node body = statement();\n                decompiler.addEOL(Token.RC);\n                pn = nf.createWhile(loop, cond, body);\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.DO: {\n            consumeToken();\n            decompiler.addToken(Token.DO);\n            decompiler.addEOL(Token.LC);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node body = statement();\n                decompiler.addToken(Token.RC);\n                mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                decompiler.addToken(Token.WHILE);\n                Node cond = condition();\n                pn = nf.createDoWhile(loop, body, cond);\n            } finally {\n                exitLoop();\n            }\n            // Always auto-insert semicon to follow SpiderMonkey:\n            // It is required by EMAScript but is ignored by the rest of\n            // world, see bug 238945\n            matchToken(Token.SEMI);\n            decompiler.addEOL(Token.SEMI);\n            return pn;\n          }\n\n          case Token.FOR: {\n            consumeToken();\n            boolean isForEach = false;\n            decompiler.addToken(Token.FOR);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n\n                Node init;  // Node init is also foo in 'foo in Object'\n                Node cond;  // Node cond is also object in 'foo in Object'\n                Node incr = null; // to kill warning\n                Node body;\n\n                // See if this is a for each () instead of just a for ()\n                if (matchToken(Token.NAME)) {\n                    decompiler.addName(ts.getString());\n                    if (ts.getString().equals(\"each\")) {\n                        isForEach = true;\n                    } else {\n                        reportError(\"msg.no.paren.for\");\n                    }\n                }\n\n                mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                decompiler.addToken(Token.LP);\n                tt = peekToken();\n                if (tt == Token.SEMI) {\n                    init = nf.createLeaf(Token.EMPTY);\n                } else {\n                    if (tt == Token.VAR) {\n                        // set init to a var list or initial\n                        consumeToken();    // consume the 'var' token\n                        init = variables(true);\n                    }\n                    else {\n                        init = expr(true);\n                    }\n                }\n\n                if (matchToken(Token.IN)) {\n                    decompiler.addToken(Token.IN);\n                    // 'cond' is the object over which we're iterating\n                    cond = expr(false);\n                } else {  // ordinary for loop\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.SEMI) {\n                        // no loop condition\n                        cond = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        cond = expr(false);\n                    }\n\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.RP) {\n                        incr = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        incr = expr(false);\n                    }\n                }\n\n                mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                decompiler.addToken(Token.RP);\n                decompiler.addEOL(Token.LC);\n                body = statement();\n                decompiler.addEOL(Token.RC);\n\n                if (incr == null) {\n                    // cond could be null if 'in obj' got eaten\n                    // by the init node.\n                    pn = nf.createForIn(loop, init, cond, body, isForEach);\n                } else {\n                    pn = nf.createFor(loop, init, cond, incr, body);\n                }\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.TRY: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            Node tryblock;\n            Node catchblocks = null;\n            Node finallyblock = null;\n\n            decompiler.addToken(Token.TRY);\n            decompiler.addEOL(Token.LC);\n            tryblock = statement();\n            decompiler.addEOL(Token.RC);\n\n            catchblocks = nf.createLeaf(Token.BLOCK);\n\n            boolean sawDefaultCatch = false;\n            int peek = peekToken();\n            if (peek == Token.CATCH) {\n                while (matchToken(Token.CATCH)) {\n                    if (sawDefaultCatch) {\n                        reportError(\"msg.catch.unreachable\");\n                    }\n                    decompiler.addToken(Token.CATCH);\n                    mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                    decompiler.addToken(Token.LP);\n\n                    mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                    String varName = ts.getString();\n                    decompiler.addName(varName);\n\n                    Node catchCond = null;\n                    if (matchToken(Token.IF)) {\n                        decompiler.addToken(Token.IF);\n                        catchCond = expr(false);\n                    } else {\n                        sawDefaultCatch = true;\n                    }\n\n                    mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                    decompiler.addToken(Token.RP);\n                    mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                    decompiler.addEOL(Token.LC);\n\n                    nf.addChildToBack(catchblocks,\n                        nf.createCatch(varName, catchCond,\n                                       statements(),\n                                       ts.getLineno()));\n\n                    mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                    decompiler.addEOL(Token.RC);\n                }\n            } else if (peek != Token.FINALLY) {\n                mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n            }\n\n            if (matchToken(Token.FINALLY)) {\n                decompiler.addToken(Token.FINALLY);\n                decompiler.addEOL(Token.LC);\n                finallyblock = statement();\n                decompiler.addEOL(Token.RC);\n            }\n\n            pn = nf.createTryCatchFinally(tryblock, catchblocks,\n                                          finallyblock, lineno);\n\n            return pn;\n          }\n\n          case Token.THROW: {\n            consumeToken();\n            if (peekTokenOrEOL() == Token.EOL) {\n                // ECMAScript does not allow new lines before throw expression,\n                // see bug 256617\n                reportError(\"msg.bad.throw.eol\");\n            }\n\n            int lineno = ts.getLineno();\n            decompiler.addToken(Token.THROW);\n            pn = nf.createThrow(expr(false), lineno);\n            break;\n          }\n\n          case Token.BREAK: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.BREAK);\n\n            // matchJumpLabelName only matches if there is one\n            Node breakStatement = matchJumpLabelName();\n            if (breakStatement == null) {\n                if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                    reportError(\"msg.bad.break\");\n                    return null;\n                }\n                breakStatement = (Node)loopAndSwitchSet.peek();\n            }\n            pn = nf.createBreak(breakStatement, lineno);\n            break;\n          }\n\n          case Token.CONTINUE: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.CONTINUE);\n\n            Node loop;\n            // matchJumpLabelName only matches if there is one\n            Node label = matchJumpLabelName();\n            if (label == null) {\n                if (loopSet == null || loopSet.size() == 0) {\n                    reportError(\"msg.continue.outside\");\n                    return null;\n                }\n                loop = (Node)loopSet.peek();\n            } else {\n                loop = nf.getLabelLoop(label);\n                if (loop == null) {\n                    reportError(\"msg.continue.nonloop\");\n                    return null;\n                }\n            }\n            pn = nf.createContinue(loop, lineno);\n            break;\n          }\n\n          case Token.WITH: {\n            consumeToken();\n\n            decompiler.addToken(Token.WITH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.with\");\n            decompiler.addToken(Token.LP);\n            Node obj = expr(false);\n            mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n            decompiler.addToken(Token.RP);\n            decompiler.addEOL(Token.LC);\n\n            ++nestingOfWith;\n            Node body;\n            try {\n                body = statement();\n            } finally {\n                --nestingOfWith;\n            }\n\n            decompiler.addEOL(Token.RC);\n\n            pn = nf.createWith(obj, body, lineno);\n            return pn;\n          }\n\n          case Token.VAR: {\n            consumeToken();\n            pn = variables(false);\n            break;\n          }\n\n          case Token.RETURN: {\n            if (!insideFunction()) {\n                reportError(\"msg.bad.return\");\n            }\n            consumeToken();\n            decompiler.addToken(Token.RETURN);\n            int lineno = ts.getLineno();\n\n            Node retExpr;\n            /* This is ugly, but we don't want to require a semicolon. */\n            tt = peekTokenOrEOL();\n            switch (tt) {\n              case Token.SEMI:\n              case Token.RC:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.ERROR:\n                retExpr = null;\n                break;\n              default:\n                retExpr = expr(false);\n            }\n            pn = nf.createReturn(retExpr, lineno);\n            break;\n          }\n\n          case Token.LC:\n            consumeToken();\n            if (statementLabel != null) {\n                decompiler.addToken(Token.LC);\n            }\n            pn = statements();\n            mustMatchToken(Token.RC, \"msg.no.brace.block\");\n            if (statementLabel != null) {\n                decompiler.addEOL(Token.RC);\n            }\n            return pn;\n\n          case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n          case Token.SEMI:\n            consumeToken();\n            pn = nf.createLeaf(Token.EMPTY);\n            return pn;\n\n          case Token.FUNCTION: {\n            consumeToken();\n            pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n            return pn;\n          }\n\n          case Token.DEFAULT :\n            consumeToken();\n            mustHaveXML();\n\n            decompiler.addToken(Token.DEFAULT);\n            int nsLine = ts.getLineno();\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"xml\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"namespace\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!matchToken(Token.ASSIGN)) {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addToken(Token.ASSIGN);\n\n            Node expr = expr(false);\n            pn = nf.createDefaultNamespace(expr, nsLine);\n            break;\n\n          case Token.NAME: {\n            int lineno = ts.getLineno();\n            String name = ts.getString();\n            setCheckForLabel();\n            pn = expr(false);\n            if (pn.getType() != Token.LABEL) {\n                pn = nf.createExprStatement(pn, lineno);\n            } else {\n                // Parsed the label: push back token should be\n                // colon that primaryExpr left untouched.\n                if (peekToken() != Token.COLON) Kit.codeBug();\n                consumeToken();\n                // depend on decompiling lookahead to guess that that\n                // last name was a label.\n                decompiler.addName(name);\n                decompiler.addEOL(Token.COLON);\n\n                if (labelSet == null) {\n                    labelSet = new Hashtable();\n                } else if (labelSet.containsKey(name)) {\n                    reportError(\"msg.dup.label\");\n                }\n\n                boolean firstLabel;\n                if (statementLabel == null) {\n                    firstLabel = true;\n                    statementLabel = pn;\n                } else {\n                    // Discard multiple label nodes and use only\n                    // the first: it allows to simplify IRFactory\n                    firstLabel = false;\n                }\n                labelSet.put(name, statementLabel);\n                try {\n                    pn = statementHelper(statementLabel);\n                } finally {\n                    labelSet.remove(name);\n                }\n                if (firstLabel) {\n                    pn = nf.createLabeledStatement(statementLabel, pn);\n                }\n                return pn;\n            }\n            break;\n          }\n\n          default: {\n            int lineno = ts.getLineno();\n            pn = expr(false);\n            pn = nf.createExprStatement(pn, lineno);\n            break;\n          }\n        }\n\n        int ttFlagged = peekFlaggedToken();\n        switch (ttFlagged & CLEAR_TI_MASK) {\n          case Token.SEMI:\n            // Consume ';' as a part of expression\n            consumeToken();\n            break;\n          case Token.ERROR:\n          case Token.EOF:\n          case Token.RC:\n            // Autoinsert ;\n            break;\n          default:\n            if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                // Report error if no EOL or autoinsert ; otherwise\n                reportError(\"msg.no.semi.stmt\");\n            }\n            break;\n        }\n        decompiler.addEOL(Token.SEMI);\n\n        return pn;\n    }\n\n    private Node variables(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = nf.createVariables(ts.getLineno());\n        boolean first = true;\n\n        decompiler.addToken(Token.VAR);\n\n        for (;;) {\n            Node name;\n            Node init;\n            mustMatchToken(Token.NAME, \"msg.bad.var\");\n            String s = ts.getString();\n\n            if (!first)\n                decompiler.addToken(Token.COMMA);\n            first = false;\n\n            decompiler.addName(s);\n            currentScriptOrFn.addVar(s);\n            name = nf.createName(s);\n\n            // omitted check for argument hiding\n\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n\n                init = assignExpr(inForInit);\n                nf.addChildToBack(name, init);\n            }\n            nf.addChildToBack(pn, name);\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return pn;\n    }\n\n    private Node expr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = condExpr(inForInit);\n\n        int tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node ifTrue;\n        Node ifFalse;\n\n        Node pn = orExpr(inForInit);\n\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = relExpr(inForInit);\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.EQ:\n              case Token.NE:\n              case Token.SHEQ:\n              case Token.SHNE:\n                consumeToken();\n                int decompilerToken = tt;\n                int parseToken = tt;\n                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                    // JavaScript 1.2 uses shallow equality for == and != .\n                    // In addition, convert === and !== for decompiler into\n                    // == and != since the decompiler is supposed to show\n                    // canonical source and in 1.2 ===, !== are allowed\n                    // only as an alias to ==, !=.\n                    switch (tt) {\n                      case Token.EQ:\n                        parseToken = Token.SHEQ;\n                        break;\n                      case Token.NE:\n                        parseToken = Token.SHNE;\n                        break;\n                      case Token.SHEQ:\n                        decompilerToken = Token.EQ;\n                        break;\n                      case Token.SHNE:\n                        decompilerToken = Token.NE;\n                        break;\n                    }\n                }\n                decompiler.addToken(decompilerToken);\n                pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = shiftExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.IN:\n                if (inForInit)\n                    break;\n                // fall through\n              case Token.INSTANCEOF:\n              case Token.LE:\n              case Token.LT:\n              case Token.GE:\n              case Token.GT:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, shiftExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr()\n        throws IOException, ParserException\n    {\n        Node pn = addExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.LSH:\n              case Token.URSH:\n              case Token.RSH:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, addExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr()\n        throws IOException, ParserException\n    {\n        Node pn = mulExpr();\n        for (;;) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node mulExpr()\n        throws IOException, ParserException\n    {\n        Node pn = unaryExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.MUL:\n              case Token.DIV:\n              case Token.MOD:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, unaryExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node unaryExpr()\n        throws IOException, ParserException\n    {\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.TYPEOF:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createUnary(tt, unaryExpr());\n\n        case Token.ADD:\n            consumeToken();\n            // Convert to special POS token in decompiler and parse tree\n            decompiler.addToken(Token.POS);\n            return nf.createUnary(Token.POS, unaryExpr());\n\n        case Token.SUB:\n            consumeToken();\n            // Convert to special NEG token in decompiler and parse tree\n            decompiler.addToken(Token.NEG);\n            return nf.createUnary(Token.NEG, unaryExpr());\n\n        case Token.INC:\n        case Token.DEC:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createIncDec(tt, false, memberExpr(true));\n\n        case Token.DELPROP:\n            consumeToken();\n            decompiler.addToken(Token.DELPROP);\n            return nf.createUnary(Token.DELPROP, unaryExpr());\n\n        case Token.ERROR:\n            consumeToken();\n            break;\n\n        // XML stream encountered in expression.\n        case Token.LT:\n            if (compilerEnv.isXmlAvailable()) {\n                consumeToken();\n                Node pn = xmlInitializer();\n                return memberExprTail(true, pn);\n            }\n            // Fall thru to the default handling of RELOP\n\n        default:\n            Node pn = memberExpr(true);\n\n            // Don't look across a newline boundary for a postfix incop.\n            tt = peekTokenOrEOL();\n            if (tt == Token.INC || tt == Token.DEC) {\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, true, pn);\n            }\n            return pn;\n        }\n        return nf.createName(\"err\"); // Only reached on error.  Try to continue.\n\n    }\n\n    private Node xmlInitializer() throws IOException\n    {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        decompiler.addToken(Token.NEW);\n        decompiler.addToken(Token.DOT);\n\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n\n        decompiler.addName(fAnonymous ? \"XMLList\" : \"XML\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n\n        pn = null;\n        Node expr;\n        for (;;tt = ts.getNextXMLToken()) {\n            switch (tt) {\n            case Token.XML:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                mustMatchToken(Token.LC, \"msg.syntax\");\n                decompiler.addToken(Token.LC);\n                expr = (peekToken() == Token.RC)\n                    ? nf.createString(\"\")\n                    : expr(false);\n                mustMatchToken(Token.RC, \"msg.syntax\");\n                decompiler.addToken(Token.RC);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n                int nodeType;\n                if (ts.isXMLAttribute()) {\n                    nodeType = Token.ESCXMLATTR;\n                } else {\n                    nodeType = Token.ESCXMLTEXT;\n                }\n                expr = nf.createUnary(nodeType, expr);\n                pn = nf.createBinary(Token.ADD, pn, expr);\n                break;\n            case Token.XMLEND:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n\n                nf.addChildToBack(pnXML, pn);\n                return pnXML;\n            default:\n                reportError(\"msg.syntax\");\n                return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode)\n        throws IOException, ParserException\n    {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax)\n        throws IOException, ParserException\n    {\n        int tt;\n\n        Node pn;\n\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn)\n        throws IOException, ParserException\n    {\n      tailLoop:\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n\n              case Token.DOT:\n              case Token.DOTDOT:\n                {\n                    int memberTypeFlags;\n                    String s;\n\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    memberTypeFlags = 0;\n                    if (tt == Token.DOTDOT) {\n                        mustHaveXML();\n                        memberTypeFlags = Node.DESCENDANTS_FLAG;\n                    }\n                    if (!compilerEnv.isXmlAvailable()) {\n                        mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                        break;\n                    }\n\n                    tt = nextToken();\n                    switch (tt) {\n                      // handles: name, ns::name, ns::*, ns::[expr]\n                      case Token.NAME:\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = propertyName(pn, s, memberTypeFlags);\n                        break;\n\n                      // handles: *, *::name, *::*, *::[expr]\n                      case Token.MUL:\n                        decompiler.addName(\"*\");\n                        pn = propertyName(pn, \"*\", memberTypeFlags);\n                        break;\n\n                      // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                      //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                      case Token.XMLATTR:\n                        decompiler.addToken(Token.XMLATTR);\n                        pn = attributeAccess(pn, memberTypeFlags);\n                        break;\n\n                      default:\n                        reportError(\"msg.no.name.after.dot\");\n                    }\n                }\n                break;\n\n              case Token.DOTQUERY:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DOTQUERY);\n                pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                break;\n\n              case Token.LB:\n                consumeToken();\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), 0);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n\n              case Token.LP:\n                if (!allowCallSyntax) {\n                    break tailLoop;\n                }\n                consumeToken();\n                decompiler.addToken(Token.LP);\n                pn = nf.createCallOrNew(Token.CALL, pn);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n                break;\n\n              default:\n                break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags)\n        throws IOException\n    {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n\n        switch (tt) {\n          // handles: @name, @ns::name, @ns::*, @ns::[expr]\n          case Token.NAME:\n            {\n                String s = ts.getString();\n                decompiler.addName(s);\n                pn = propertyName(pn, s, memberTypeFlags);\n            }\n            break;\n\n          // handles: @*, @*::name, @*::*, @*::[expr]\n          case Token.MUL:\n            decompiler.addName(\"*\");\n            pn = propertyName(pn, \"*\", memberTypeFlags);\n            break;\n\n          // handles @[expr]\n          case Token.LB:\n            decompiler.addToken(Token.LB);\n            pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n            mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n            decompiler.addToken(Token.RB);\n            break;\n\n          default:\n            reportError(\"msg.no.name.after.xmlAttr\");\n            pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n            break;\n        }\n\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags)\n        throws IOException, ParserException\n    {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n\n            int tt = nextToken();\n            switch (tt) {\n              // handles name::name\n              case Token.NAME:\n                name = ts.getString();\n                decompiler.addName(name);\n                break;\n\n              // handles name::*\n              case Token.MUL:\n                decompiler.addName(\"*\");\n                name = \"*\";\n                break;\n\n              // handles name::[expr]\n              case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, namespace, expr(false),\n                                         memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                return pn;\n\n              default:\n                reportError(\"msg.no.name.after.coloncolon\");\n                name = \"?\";\n            }\n        }\n\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node primaryExpr()\n        throws IOException, ParserException\n    {\n        Node pn;\n\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n\n        switch(tt) {\n\n          case Token.FUNCTION:\n            return function(FunctionNode.FUNCTION_EXPRESSION);\n\n          case Token.LB: {\n            ObjArray elems = new ObjArray();\n            int skipCount = 0;\n            decompiler.addToken(Token.LB);\n            boolean after_lb_or_comma = true;\n            for (;;) {\n                tt = peekToken();\n\n                if (tt == Token.COMMA) {\n                    consumeToken();\n                    decompiler.addToken(Token.COMMA);\n                    if (!after_lb_or_comma) {\n                        after_lb_or_comma = true;\n                    } else {\n                        elems.add(null);\n                        ++skipCount;\n                    }\n                } else if (tt == Token.RB) {\n                    consumeToken();\n                    decompiler.addToken(Token.RB);\n                    break;\n                } else {\n                    if (!after_lb_or_comma) {\n                        reportError(\"msg.no.bracket.arg\");\n                    }\n                    elems.add(assignExpr(false));\n                    after_lb_or_comma = false;\n                }\n            }\n            return nf.createArrayLiteral(elems, skipCount);\n          }\n\n          case Token.LC: {\n            ObjArray elems = new ObjArray();\n            decompiler.addToken(Token.LC);\n            if (!matchToken(Token.RC)) {\n\n                boolean first = true;\n            commaloop:\n                do {\n                    Object property;\n\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    else\n                        first = false;\n\n                    tt = peekToken();\n                    switch(tt) {\n                      case Token.NAME:\n                      case Token.STRING:\n                        consumeToken();\n                        // map NAMEs to STRINGs in object literal context\n                        // but tell the decompiler the proper type\n                        String s = ts.getString();\n                        if (tt == Token.NAME) {\n                            decompiler.addName(s);\n                        } else {\n                            decompiler.addString(s);\n                        }\n                        property = ScriptRuntime.getIndexObject(s);\n                        break;\n\n                      case Token.NUMBER:\n                        consumeToken();\n                        double n = ts.getNumber();\n                        decompiler.addNumber(n);\n                        property = ScriptRuntime.getIndexObject(n);\n                        break;\n\n                      case Token.RC:\n                        // trailing comma is OK.\n                        break commaloop;\n                    default:\n                        reportError(\"msg.bad.prop\");\n                        break commaloop;\n                    }\n                    mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n\n                    // OBJLIT is used as ':' in object literal for\n                    // decompilation to solve spacing ambiguity.\n                    decompiler.addToken(Token.OBJECTLIT);\n                    elems.add(property);\n                    elems.add(assignExpr(false));\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n            }\n            decompiler.addToken(Token.RC);\n            return nf.createObjectLiteral(elems);\n          }\n\n          case Token.LP:\n\n            /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n            decompiler.addToken(Token.LP);\n            pn = expr(false);\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.RP, \"msg.no.paren\");\n            return pn;\n\n          case Token.XMLATTR:\n            mustHaveXML();\n            decompiler.addToken(Token.XMLATTR);\n            pn = attributeAccess(null, 0);\n            return pn;\n\n          case Token.NAME: {\n            String name = ts.getString();\n            if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                if (peekToken() == Token.COLON) {\n                    // Do not consume colon, it is used as unwind indicator\n                    // to return to statementHelper.\n                    // XXX Better way?\n                    return nf.createLabel(ts.getLineno());\n                }\n            }\n\n            decompiler.addName(name);\n            if (compilerEnv.isXmlAvailable()) {\n                pn = propertyName(null, name, 0);\n            } else {\n                pn = nf.createName(name);\n            }\n            return pn;\n          }\n\n          case Token.NUMBER: {\n            double n = ts.getNumber();\n            decompiler.addNumber(n);\n            return nf.createNumber(n);\n          }\n\n          case Token.STRING: {\n            String s = ts.getString();\n            decompiler.addString(s);\n            return nf.createString(s);\n          }\n\n          case Token.DIV:\n          case Token.ASSIGN_DIV: {\n            // Got / or /= which should be treated as regexp in fact\n            ts.readRegExp(tt);\n            String flags = ts.regExpFlags;\n            ts.regExpFlags = null;\n            String re = ts.getString();\n            decompiler.addRegexp(re, flags);\n            int index = currentScriptOrFn.addRegexp(re, flags);\n            return nf.createRegExp(index);\n          }\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.FALSE:\n          case Token.TRUE:\n            decompiler.addToken(tt);\n            return nf.createLeaf(tt);\n\n          case Token.RESERVED:\n            reportError(\"msg.reserved.id\");\n            break;\n\n          case Token.ERROR:\n            /* the scanner or one of its subroutines reported the error. */\n            break;\n\n          case Token.EOF:\n            reportError(\"msg.unexpected.eof\");\n            break;\n\n          default:\n            reportError(\"msg.syntax\");\n            break;\n        }\n        return null;    // should never reach here\n    }\n\n}\n\n"
-return.toString == "private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }"
+source.toString == "/* -*- Mode: java; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-\n *\n * The contents of this file are subject to the Netscape Public\n * License Version 1.1 (the \"License\"); you may not use this file\n * except in compliance with the License. You may obtain a copy of\n * the License at http://www.mozilla.org/NPL/\n *\n * Software distributed under the License is distributed on an \"AS\n * IS\" basis, WITHOUT WARRANTY OF ANY KIND, either express or\n * implied. See the License for the specific language governing\n * rights and limitations under the License.\n *\n * The Variant Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Variant Code is Netscape\n * Communications Corporation.  Portions created by Netscape are\n * Copyright (C) 1997-1999 Netscape Communications Corporation. All\n * Rights Reserved.\n *\n * Contributor(s):\n * Mike Ang\n * Igor Bukanov\n * Ethan Hugg\n * Terry Lucas\n * Mike McCabe\n * Milen Nankov\n *\n * Alternatively, the contents of this file may be used under the\n * terms of the GNU Public License (the \"GPL\"), in which case the\n * provisions of the GPL are applicable instead of those above.\n * If you wish to allow use of your version of this file only\n * under the terms of the GPL and not to allow others to use your\n * version of this file under the NPL, indicate your decision by\n * deleting the provisions above and replace them with the notice\n * and other provisions required by the GPL.  If you do not delete\n * the provisions above, a recipient may use your version of this\n * file under either the NPL or the GPL.\n */\n\npackage rhino._1.VARIANT;\n\nimport java.io.Reader;\nimport java.io.IOException;\nimport java.util.Hashtable;\n\nimport rhino._1.mocks.*;\n\n/**\n * This class implements the JavaScript parser.\n *\n * It is based on the C source files jsparse.c and jsparse.h\n * in the jsref package.\n *\n * @see TokenStream\n *\n * @author Mike McCabe\n * @author Brendan Eich\n */\n\npublic class Parser\n{\n    // TokenInformation flags : currentFlaggedToken stores them together\n    // with token type\n    final static int\n        CLEAR_TI_MASK  = 0xFFFF,   // mask to clear token information bits\n        TI_AFTER_EOL   = 1 << 16,  // first token of the source line\n        TI_CHECK_LABEL = 1 << 17;  // indicates to check for label\n\n    CompilerEnvirons compilerEnv;\n    private ErrorReporter errorReporter;\n    private String sourceURI;\n\n    private TokenStream ts;\n    private int currentFlaggedToken;\n    private int syntaxErrorCount;\n\n    private IRFactory nf;\n\n    private int nestingOfFunction;\n\n    private Decompiler decompiler;\n    private String encodedSource;\n\n// The following are per function variables and should be saved/restored\n// during function parsing.\n// XXX Move to separated class?\n    ScriptOrFnNode currentScriptOrFn;\n    private int nestingOfWith;\n    private Hashtable labelSet; // map of label names into nodes\n    private ObjArray loopSet;\n    private ObjArray loopAndSwitchSet;\n// end of per function variables\n\n    // Exception to unwind\n    private static class ParserException extends RuntimeException\n    {\n    }\n\n    public Parser(CompilerEnvirons compilerEnv, ErrorReporter errorReporter)\n    {\n        this.compilerEnv = compilerEnv;\n        this.errorReporter = errorReporter;\n    }\n\n    protected Decompiler createDecompiler(CompilerEnvirons compilerEnv)\n    {\n        return new Decompiler();\n    }\n\n    void addWarning(String messageId, String messageArg)\n    {\n        String message = ScriptRuntime.getMessage1(messageId, messageArg);\n        errorReporter.warning(message, sourceURI, ts.getLineno(),\n                              ts.getLine(), ts.getOffset());\n    }\n\n    void addError(String messageId)\n    {\n        ++syntaxErrorCount;\n        String message = ScriptRuntime.getMessage0(messageId);\n        errorReporter.error(message, sourceURI, ts.getLineno(),\n                            ts.getLine(), ts.getOffset());\n    }\n\n    RuntimeException reportError(String messageId)\n    {\n        addError(messageId);\n\n        // Throw a ParserException exception to unwind the recursive descent\n        // parse.\n        throw new ParserException();\n    }\n\n    private int peekToken()\n        throws IOException\n    {\n        int tt = currentFlaggedToken;\n        if (tt == Token.EOF) {\n            tt = ts.getToken();\n            if (tt == Token.EOL) {\n                do {\n                    tt = ts.getToken();\n                } while (tt == Token.EOL);\n                tt |= TI_AFTER_EOL;\n            }\n            currentFlaggedToken = tt;\n        }\n        return tt & CLEAR_TI_MASK;\n    }\n\n    private int peekFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        return currentFlaggedToken;\n    }\n\n    private void consumeToken()\n    {\n        currentFlaggedToken = Token.EOF;\n    }\n\n    private int nextToken()\n        throws IOException\n    {\n        int tt = peekToken();\n        consumeToken();\n        return tt;\n    }\n\n    private int nextFlaggedToken()\n        throws IOException\n    {\n        peekToken();\n        int ttFlagged = currentFlaggedToken;\n        consumeToken();\n        return ttFlagged;\n    }\n\n    private boolean matchToken(int toMatch)\n        throws IOException\n    {\n        int tt = peekToken();\n        if (tt != toMatch) {\n            return false;\n        }\n        consumeToken();\n        return true;\n    }\n\n    private int peekTokenOrEOL()\n        throws IOException\n    {\n        int tt = peekToken();\n        // Check for last peeked token flags\n        if ((currentFlaggedToken & TI_AFTER_EOL) != 0) {\n            tt = Token.EOL;\n        }\n        return tt;\n    }\n\n    private void setCheckForLabel()\n    {\n        if ((currentFlaggedToken & CLEAR_TI_MASK) != Token.NAME)\n            throw Kit.codeBug();\n        currentFlaggedToken |= TI_CHECK_LABEL;\n    }\n\n    private void mustMatchToken(int toMatch, String messageId)\n        throws IOException, ParserException\n    {\n        if (!matchToken(toMatch)) {\n            reportError(messageId);\n        }\n    }\n\n    private void mustHaveXML()\n    {\n        if (!compilerEnv.isXmlAvailable()) {\n            reportError(\"msg.XML.not.available\");\n        }\n    }\n\n    public String getEncodedSource()\n    {\n        return encodedSource;\n    }\n\n    public boolean eof()\n    {\n        return ts.eof();\n    }\n\n    boolean insideFunction()\n    {\n        return nestingOfFunction != 0;\n    }\n\n    private Node enterLoop(Node loopLabel)\n    {\n        Node loop = nf.createLoopNode(loopLabel, ts.getLineno());\n        if (loopSet == null) {\n            loopSet = new ObjArray();\n            if (loopAndSwitchSet == null) {\n                loopAndSwitchSet = new ObjArray();\n            }\n        }\n        loopSet.push(loop);\n        loopAndSwitchSet.push(loop);\n        return loop;\n    }\n\n    private void exitLoop()\n    {\n        loopSet.pop();\n        loopAndSwitchSet.pop();\n    }\n\n    private Node enterSwitch(Node switchSelector, int lineno, Node switchLabel)\n    {\n        Node switchNode = nf.createSwitch(switchSelector, lineno);\n        if (loopAndSwitchSet == null) {\n            loopAndSwitchSet = new ObjArray();\n        }\n        loopAndSwitchSet.push(switchNode);\n        return switchNode;\n    }\n\n    private void exitSwitch()\n    {\n        loopAndSwitchSet.pop();\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(String sourceString,\n                                String sourceURI, int lineno)\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, null, sourceString, lineno);\n        try {\n            return parse();\n        } catch (IOException ex) {\n            // Should never happen\n            throw new IllegalStateException();\n        }\n    }\n\n    /*\n     * Build a parse tree from the given sourceString.\n     *\n     * @return an Object representing the parsed\n     * program.  If the parse fails, null will be returned.  (The\n     * parse failure will result in a call to the ErrorReporter from\n     * CompilerEnvirons.)\n     */\n    public ScriptOrFnNode parse(Reader sourceReader,\n                                String sourceURI, int lineno)\n        throws IOException\n    {\n        this.sourceURI = sourceURI;\n        this.ts = new TokenStream(this, sourceReader, null, lineno);\n        return parse();\n    }\n\n    private ScriptOrFnNode parse()\n        throws IOException\n    {\n        this.decompiler = createDecompiler(compilerEnv);\n        this.nf = new IRFactory(this);\n        currentScriptOrFn = nf.createScript();\n        int sourceStartOffset = decompiler.getCurrentOffset();\n        this.encodedSource = null;\n        decompiler.addToken(Token.SCRIPT);\n\n        this.currentFlaggedToken = Token.EOF;\n        this.syntaxErrorCount = 0;\n\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        /* so we have something to add nodes to until\n         * we've collected all the source */\n        Node pn = nf.createLeaf(Token.BLOCK);\n\n        try {\n            for (;;) {\n                int tt = peekToken();\n\n                if (tt <= Token.EOF) {\n                    break;\n                }\n\n                Node n;\n                if (tt == Token.FUNCTION) {\n                    consumeToken();\n                    try {\n                        n = function(FunctionNode.FUNCTION_STATEMENT);\n                    } catch (ParserException e) {\n                        break;\n                    }\n                } else {\n                    n = statement();\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (StackOverflowError ex) {\n            String msg = ScriptRuntime.getMessage0(\n                \"mag.too.deep.parser.recursion\");\n            throw Context.reportRuntimeError(msg, sourceURI,\n                                             ts.getLineno(), null, 0);\n        }\n\n        if (this.syntaxErrorCount != 0) {\n            String msg = String.valueOf(this.syntaxErrorCount);\n            msg = ScriptRuntime.getMessage1(\"msg.got.syntax.errors\", msg);\n            throw errorReporter.runtimeError(msg, sourceURI, baseLineno,\n                                             null, 0);\n        }\n\n        currentScriptOrFn.setSourceName(sourceURI);\n        currentScriptOrFn.setBaseLineno(baseLineno);\n        currentScriptOrFn.setEndLineno(ts.getLineno());\n\n        int sourceEndOffset = decompiler.getCurrentOffset();\n        currentScriptOrFn.setEncodedSourceBounds(sourceStartOffset,\n                                                 sourceEndOffset);\n\n        nf.initScript(currentScriptOrFn, pn);\n\n        if (compilerEnv.isGeneratingSource()) {\n            encodedSource = decompiler.getEncodedSource();\n        }\n        this.decompiler = null; // It helps GC\n\n        return currentScriptOrFn;\n    }\n\n    /*\n     * The C version of this function takes an argument list,\n     * which doesn't seem to be needed for tree generation...\n     * it'd only be useful for checking argument hiding, which\n     * I'm not doing anyway...\n     */\n    private Node parseFunctionBody()\n        throws IOException\n    {\n        ++nestingOfFunction;\n        Node pn = nf.createBlock(ts.getLineno());\n        try {\n            bodyLoop: for (;;) {\n                Node n;\n                int tt = peekToken();\n                switch (tt) {\n                  case Token.ERROR:\n                  case Token.EOF:\n                  case Token.RC:\n                    break bodyLoop;\n\n                  case Token.FUNCTION:\n                    consumeToken();\n                    n = function(FunctionNode.FUNCTION_STATEMENT);\n                    break;\n                  default:\n                    n = statement();\n                    break;\n                }\n                nf.addChildToBack(pn, n);\n            }\n        } catch (ParserException e) {\n            // Ignore it\n        } finally {\n            --nestingOfFunction;\n        }\n\n        return pn;\n    }\n\n    private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }\n\n    private Node statements()\n        throws IOException\n    {\n        Node pn = nf.createBlock(ts.getLineno());\n\n        int tt;\n        while((tt = peekToken()) > Token.EOF && tt != Token.RC) {\n            nf.addChildToBack(pn, statement());\n        }\n\n        return pn;\n    }\n\n    private Node condition()\n        throws IOException, ParserException\n    {\n        Node pn;\n        mustMatchToken(Token.LP, \"msg.no.paren.cond\");\n        decompiler.addToken(Token.LP);\n        pn = expr(false);\n        mustMatchToken(Token.RP, \"msg.no.paren.after.cond\");\n        decompiler.addToken(Token.RP);\n\n        // there's a check here in jsparse.c that corrects = to ==\n\n        return pn;\n    }\n\n    // match a NAME; return null if no match.\n    private Node matchJumpLabelName()\n        throws IOException, ParserException\n    {\n        Node label = null;\n\n        int tt = peekTokenOrEOL();\n        if (tt == Token.NAME) {\n            consumeToken();\n            String name = ts.getString();\n            decompiler.addName(name);\n            if (labelSet != null) {\n                label = (Node)labelSet.get(name);\n            }\n            if (label == null) {\n                reportError(\"msg.undef.label\");\n            }\n        }\n\n        return label;\n    }\n\n    private Node statement()\n        throws IOException\n    {\n        try {\n            Node pn = statementHelper(null);\n            if (pn != null) {\n                return pn;\n            }\n        } catch (ParserException e) { }\n\n        // skip to end of statement\n        int lineno = ts.getLineno();\n        guessingStatementEnd: for (;;) {\n            int tt = peekTokenOrEOL();\n            consumeToken();\n            switch (tt) {\n              case Token.ERROR:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.SEMI:\n                break guessingStatementEnd;\n            }\n        }\n        return nf.createExprStatement(nf.createName(\"error\"), lineno);\n    }\n\n    /**\n     * Whether the \"catch (e: e instanceof Exception) { ... }\" syntax\n     * is implemented.\n     */\n\n    private Node statementHelper(Node statementLabel)\n        throws IOException, ParserException\n    {\n        Node pn = null;\n\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n          case Token.IF: {\n            consumeToken();\n\n            decompiler.addToken(Token.IF);\n            int lineno = ts.getLineno();\n            Node cond = condition();\n            decompiler.addEOL(Token.LC);\n            Node ifTrue = statement();\n            Node ifFalse = null;\n            if (matchToken(Token.ELSE)) {\n                decompiler.addToken(Token.RC);\n                decompiler.addToken(Token.ELSE);\n                decompiler.addEOL(Token.LC);\n                ifFalse = statement();\n            }\n            decompiler.addEOL(Token.RC);\n            pn = nf.createIf(cond, ifTrue, ifFalse, lineno);\n            return pn;\n          }\n\n          case Token.SWITCH: {\n            consumeToken();\n\n            decompiler.addToken(Token.SWITCH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.switch\");\n            decompiler.addToken(Token.LP);\n            pn = enterSwitch(expr(false), lineno, statementLabel);\n            try {\n                mustMatchToken(Token.RP, \"msg.no.paren.after.switch\");\n                decompiler.addToken(Token.RP);\n                mustMatchToken(Token.LC, \"msg.no.brace.switch\");\n                decompiler.addEOL(Token.LC);\n\n                boolean hasDefault = false;\n                switchLoop: for (;;) {\n                    tt = nextToken();\n                    Node caseExpression;\n                    switch (tt) {\n                      case Token.RC:\n                        break switchLoop;\n\n                      case Token.CASE:\n                        decompiler.addToken(Token.CASE);\n                        caseExpression = expr(false);\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      case Token.DEFAULT:\n                        if (hasDefault) {\n                            reportError(\"msg.double.switch.default\");\n                        }\n                        decompiler.addToken(Token.DEFAULT);\n                        hasDefault = true;\n                        caseExpression = null;\n                        mustMatchToken(Token.COLON, \"msg.no.colon.case\");\n                        decompiler.addEOL(Token.COLON);\n                        break;\n\n                      default:\n                        reportError(\"msg.bad.switch\");\n                        break switchLoop;\n                    }\n\n                    Node block = nf.createLeaf(Token.BLOCK);\n                    while ((tt = peekToken()) != Token.RC\n                           && tt != Token.CASE\n                           && tt != Token.DEFAULT\n                           && tt != Token.EOF)\n                    {\n                        nf.addChildToBack(block, statement());\n                    }\n\n                    // caseExpression == null => add default lable\n                    nf.addSwitchCase(pn, caseExpression, block);\n                }\n                decompiler.addEOL(Token.RC);\n                nf.closeSwitch(pn);\n            } finally {\n                exitSwitch();\n            }\n            return pn;\n          }\n\n          case Token.WHILE: {\n            consumeToken();\n            decompiler.addToken(Token.WHILE);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node cond = condition();\n                decompiler.addEOL(Token.LC);\n                Node body = statement();\n                decompiler.addEOL(Token.RC);\n                pn = nf.createWhile(loop, cond, body);\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.DO: {\n            consumeToken();\n            decompiler.addToken(Token.DO);\n            decompiler.addEOL(Token.LC);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n                Node body = statement();\n                decompiler.addToken(Token.RC);\n                mustMatchToken(Token.WHILE, \"msg.no.while.do\");\n                decompiler.addToken(Token.WHILE);\n                Node cond = condition();\n                pn = nf.createDoWhile(loop, body, cond);\n            } finally {\n                exitLoop();\n            }\n            // Always auto-insert semicon to follow SpiderMonkey:\n            // It is required by EMAScript but is ignored by the rest of\n            // world, see bug 238945\n            matchToken(Token.SEMI);\n            decompiler.addEOL(Token.SEMI);\n            return pn;\n          }\n\n          case Token.FOR: {\n            consumeToken();\n            boolean isForEach = false;\n            decompiler.addToken(Token.FOR);\n\n            Node loop = enterLoop(statementLabel);\n            try {\n\n                Node init;  // Node init is also foo in 'foo in Object'\n                Node cond;  // Node cond is also object in 'foo in Object'\n                Node incr = null; // to kill warning\n                Node body;\n\n                // See if this is a for each () instead of just a for ()\n                if (matchToken(Token.NAME)) {\n                    decompiler.addName(ts.getString());\n                    if (ts.getString().equals(\"each\")) {\n                        isForEach = true;\n                    } else {\n                        reportError(\"msg.no.paren.for\");\n                    }\n                }\n\n                mustMatchToken(Token.LP, \"msg.no.paren.for\");\n                decompiler.addToken(Token.LP);\n                tt = peekToken();\n                if (tt == Token.SEMI) {\n                    init = nf.createLeaf(Token.EMPTY);\n                } else {\n                    if (tt == Token.VAR) {\n                        // set init to a var list or initial\n                        consumeToken();    // consume the 'var' token\n                        init = variables(true);\n                    }\n                    else {\n                        init = expr(true);\n                    }\n                }\n\n                if (matchToken(Token.IN)) {\n                    decompiler.addToken(Token.IN);\n                    // 'cond' is the object over which we're iterating\n                    cond = expr(false);\n                } else {  // ordinary for loop\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.SEMI) {\n                        // no loop condition\n                        cond = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        cond = expr(false);\n                    }\n\n                    mustMatchToken(Token.SEMI, \"msg.no.semi.for.cond\");\n                    decompiler.addToken(Token.SEMI);\n                    if (peekToken() == Token.RP) {\n                        incr = nf.createLeaf(Token.EMPTY);\n                    } else {\n                        incr = expr(false);\n                    }\n                }\n\n                mustMatchToken(Token.RP, \"msg.no.paren.for.ctrl\");\n                decompiler.addToken(Token.RP);\n                decompiler.addEOL(Token.LC);\n                body = statement();\n                decompiler.addEOL(Token.RC);\n\n                if (incr == null) {\n                    // cond could be null if 'in obj' got eaten\n                    // by the init node.\n                    pn = nf.createForIn(loop, init, cond, body, isForEach);\n                } else {\n                    pn = nf.createFor(loop, init, cond, incr, body);\n                }\n            } finally {\n                exitLoop();\n            }\n            return pn;\n          }\n\n          case Token.TRY: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            Node tryblock;\n            Node catchblocks = null;\n            Node finallyblock = null;\n\n            decompiler.addToken(Token.TRY);\n            decompiler.addEOL(Token.LC);\n            tryblock = statement();\n            decompiler.addEOL(Token.RC);\n\n            catchblocks = nf.createLeaf(Token.BLOCK);\n\n            boolean sawDefaultCatch = false;\n            int peek = peekToken();\n            if (peek == Token.CATCH) {\n                while (matchToken(Token.CATCH)) {\n                    if (sawDefaultCatch) {\n                        reportError(\"msg.catch.unreachable\");\n                    }\n                    decompiler.addToken(Token.CATCH);\n                    mustMatchToken(Token.LP, \"msg.no.paren.catch\");\n                    decompiler.addToken(Token.LP);\n\n                    mustMatchToken(Token.NAME, \"msg.bad.catchcond\");\n                    String varName = ts.getString();\n                    decompiler.addName(varName);\n\n                    Node catchCond = null;\n                    if (matchToken(Token.IF)) {\n                        decompiler.addToken(Token.IF);\n                        catchCond = expr(false);\n                    } else {\n                        sawDefaultCatch = true;\n                    }\n\n                    mustMatchToken(Token.RP, \"msg.bad.catchcond\");\n                    decompiler.addToken(Token.RP);\n                    mustMatchToken(Token.LC, \"msg.no.brace.catchblock\");\n                    decompiler.addEOL(Token.LC);\n\n                    nf.addChildToBack(catchblocks,\n                        nf.createCatch(varName, catchCond,\n                                       statements(),\n                                       ts.getLineno()));\n\n                    mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n                    decompiler.addEOL(Token.RC);\n                }\n            } else if (peek != Token.FINALLY) {\n                mustMatchToken(Token.FINALLY, \"msg.try.no.catchfinally\");\n            }\n\n            if (matchToken(Token.FINALLY)) {\n                decompiler.addToken(Token.FINALLY);\n                decompiler.addEOL(Token.LC);\n                finallyblock = statement();\n                decompiler.addEOL(Token.RC);\n            }\n\n            pn = nf.createTryCatchFinally(tryblock, catchblocks,\n                                          finallyblock, lineno);\n\n            return pn;\n          }\n\n          case Token.THROW: {\n            consumeToken();\n            if (peekTokenOrEOL() == Token.EOL) {\n                // ECMAScript does not allow new lines before throw expression,\n                // see bug 256617\n                reportError(\"msg.bad.throw.eol\");\n            }\n\n            int lineno = ts.getLineno();\n            decompiler.addToken(Token.THROW);\n            pn = nf.createThrow(expr(false), lineno);\n            break;\n          }\n\n          case Token.BREAK: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.BREAK);\n\n            // matchJumpLabelName only matches if there is one\n            Node breakStatement = matchJumpLabelName();\n            if (breakStatement == null) {\n                if (loopAndSwitchSet == null || loopAndSwitchSet.size() == 0) {\n                    reportError(\"msg.bad.break\");\n                    return null;\n                }\n                breakStatement = (Node)loopAndSwitchSet.peek();\n            }\n            pn = nf.createBreak(breakStatement, lineno);\n            break;\n          }\n\n          case Token.CONTINUE: {\n            consumeToken();\n            int lineno = ts.getLineno();\n\n            decompiler.addToken(Token.CONTINUE);\n\n            Node loop;\n            // matchJumpLabelName only matches if there is one\n            Node label = matchJumpLabelName();\n            if (label == null) {\n                if (loopSet == null || loopSet.size() == 0) {\n                    reportError(\"msg.continue.outside\");\n                    return null;\n                }\n                loop = (Node)loopSet.peek();\n            } else {\n                loop = nf.getLabelLoop(label);\n                if (loop == null) {\n                    reportError(\"msg.continue.nonloop\");\n                    return null;\n                }\n            }\n            pn = nf.createContinue(loop, lineno);\n            break;\n          }\n\n          case Token.WITH: {\n            consumeToken();\n\n            decompiler.addToken(Token.WITH);\n            int lineno = ts.getLineno();\n            mustMatchToken(Token.LP, \"msg.no.paren.with\");\n            decompiler.addToken(Token.LP);\n            Node obj = expr(false);\n            mustMatchToken(Token.RP, \"msg.no.paren.after.with\");\n            decompiler.addToken(Token.RP);\n            decompiler.addEOL(Token.LC);\n\n            ++nestingOfWith;\n            Node body;\n            try {\n                body = statement();\n            } finally {\n                --nestingOfWith;\n            }\n\n            decompiler.addEOL(Token.RC);\n\n            pn = nf.createWith(obj, body, lineno);\n            return pn;\n          }\n\n          case Token.VAR: {\n            consumeToken();\n            pn = variables(false);\n            break;\n          }\n\n          case Token.RETURN: {\n            if (!insideFunction()) {\n                reportError(\"msg.bad.return\");\n            }\n            consumeToken();\n            decompiler.addToken(Token.RETURN);\n            int lineno = ts.getLineno();\n\n            Node retExpr;\n            /* This is ugly, but we don't want to require a semicolon. */\n            tt = peekTokenOrEOL();\n            switch (tt) {\n              case Token.SEMI:\n              case Token.RC:\n              case Token.EOF:\n              case Token.EOL:\n              case Token.ERROR:\n                retExpr = null;\n                break;\n              default:\n                retExpr = expr(false);\n            }\n            pn = nf.createReturn(retExpr, lineno);\n            break;\n          }\n\n          case Token.LC:\n            consumeToken();\n            if (statementLabel != null) {\n                decompiler.addToken(Token.LC);\n            }\n            pn = statements();\n            mustMatchToken(Token.RC, \"msg.no.brace.block\");\n            if (statementLabel != null) {\n                decompiler.addEOL(Token.RC);\n            }\n            return pn;\n\n          case Token.ERROR:\n            // Fall thru, to have a node for error recovery to work on\n          case Token.SEMI:\n            consumeToken();\n            pn = nf.createLeaf(Token.EMPTY);\n            return pn;\n\n          case Token.FUNCTION: {\n            consumeToken();\n            pn = function(FunctionNode.FUNCTION_EXPRESSION_STATEMENT);\n            return pn;\n          }\n\n          case Token.DEFAULT :\n            consumeToken();\n            mustHaveXML();\n\n            decompiler.addToken(Token.DEFAULT);\n            int nsLine = ts.getLineno();\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"xml\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!(matchToken(Token.NAME)\n                  && ts.getString().equals(\"namespace\")))\n            {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addName(ts.getString());\n\n            if (!matchToken(Token.ASSIGN)) {\n                reportError(\"msg.bad.namespace\");\n            }\n            decompiler.addToken(Token.ASSIGN);\n\n            Node expr = expr(false);\n            pn = nf.createDefaultNamespace(expr, nsLine);\n            break;\n\n          case Token.NAME: {\n            int lineno = ts.getLineno();\n            String name = ts.getString();\n            setCheckForLabel();\n            pn = expr(false);\n            if (pn.getType() != Token.LABEL) {\n                pn = nf.createExprStatement(pn, lineno);\n            } else {\n                // Parsed the label: push back token should be\n                // colon that primaryExpr left untouched.\n                if (peekToken() != Token.COLON) Kit.codeBug();\n                consumeToken();\n                // depend on decompiling lookahead to guess that that\n                // last name was a label.\n                decompiler.addName(name);\n                decompiler.addEOL(Token.COLON);\n\n                if (labelSet == null) {\n                    labelSet = new Hashtable();\n                } else if (labelSet.containsKey(name)) {\n                    reportError(\"msg.dup.label\");\n                }\n\n                boolean firstLabel;\n                if (statementLabel == null) {\n                    firstLabel = true;\n                    statementLabel = pn;\n                } else {\n                    // Discard multiple label nodes and use only\n                    // the first: it allows to simplify IRFactory\n                    firstLabel = false;\n                }\n                labelSet.put(name, statementLabel);\n                try {\n                    pn = statementHelper(statementLabel);\n                } finally {\n                    labelSet.remove(name);\n                }\n                if (firstLabel) {\n                    pn = nf.createLabeledStatement(statementLabel, pn);\n                }\n                return pn;\n            }\n            break;\n          }\n\n          default: {\n            int lineno = ts.getLineno();\n            pn = expr(false);\n            pn = nf.createExprStatement(pn, lineno);\n            break;\n          }\n        }\n\n        int ttFlagged = peekFlaggedToken();\n        switch (ttFlagged & CLEAR_TI_MASK) {\n          case Token.SEMI:\n            // Consume ';' as a part of expression\n            consumeToken();\n            break;\n          case Token.ERROR:\n          case Token.EOF:\n          case Token.RC:\n            // Autoinsert ;\n            break;\n          default:\n            if ((ttFlagged & TI_AFTER_EOL) == 0) {\n                // Report error if no EOL or autoinsert ; otherwise\n                reportError(\"msg.no.semi.stmt\");\n            }\n            break;\n        }\n        decompiler.addEOL(Token.SEMI);\n\n        return pn;\n    }\n\n    private Node variables(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = nf.createVariables(ts.getLineno());\n        boolean first = true;\n\n        decompiler.addToken(Token.VAR);\n\n        for (;;) {\n            Node name;\n            Node init;\n            mustMatchToken(Token.NAME, \"msg.bad.var\");\n            String s = ts.getString();\n\n            if (!first)\n                decompiler.addToken(Token.COMMA);\n            first = false;\n\n            decompiler.addName(s);\n            currentScriptOrFn.addVar(s);\n            name = nf.createName(s);\n\n            // omitted check for argument hiding\n\n            if (matchToken(Token.ASSIGN)) {\n                decompiler.addToken(Token.ASSIGN);\n\n                init = assignExpr(inForInit);\n                nf.addChildToBack(name, init);\n            }\n            nf.addChildToBack(pn, name);\n            if (!matchToken(Token.COMMA))\n                break;\n        }\n        return pn;\n    }\n\n    private Node expr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = assignExpr(inForInit);\n        while (matchToken(Token.COMMA)) {\n            decompiler.addToken(Token.COMMA);\n            pn = nf.createBinary(Token.COMMA, pn, assignExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node assignExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = condExpr(inForInit);\n\n        int tt = peekToken();\n        if (Token.FIRST_ASSIGN <= tt && tt <= Token.LAST_ASSIGN) {\n            consumeToken();\n            decompiler.addToken(tt);\n            pn = nf.createAssignment(tt, pn, assignExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node condExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node ifTrue;\n        Node ifFalse;\n\n        Node pn = orExpr(inForInit);\n\n        if (matchToken(Token.HOOK)) {\n            decompiler.addToken(Token.HOOK);\n            ifTrue = assignExpr(false);\n            mustMatchToken(Token.COLON, \"msg.no.colon.cond\");\n            decompiler.addToken(Token.COLON);\n            ifFalse = assignExpr(inForInit);\n            return nf.createCondExpr(pn, ifTrue, ifFalse);\n        }\n\n        return pn;\n    }\n\n    private Node orExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = andExpr(inForInit);\n        if (matchToken(Token.OR)) {\n            decompiler.addToken(Token.OR);\n            pn = nf.createBinary(Token.OR, pn, orExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node andExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitOrExpr(inForInit);\n        if (matchToken(Token.AND)) {\n            decompiler.addToken(Token.AND);\n            pn = nf.createBinary(Token.AND, pn, andExpr(inForInit));\n        }\n\n        return pn;\n    }\n\n    private Node bitOrExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitXorExpr(inForInit);\n        while (matchToken(Token.BITOR)) {\n            decompiler.addToken(Token.BITOR);\n            pn = nf.createBinary(Token.BITOR, pn, bitXorExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitXorExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = bitAndExpr(inForInit);\n        while (matchToken(Token.BITXOR)) {\n            decompiler.addToken(Token.BITXOR);\n            pn = nf.createBinary(Token.BITXOR, pn, bitAndExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node bitAndExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = eqExpr(inForInit);\n        while (matchToken(Token.BITAND)) {\n            decompiler.addToken(Token.BITAND);\n            pn = nf.createBinary(Token.BITAND, pn, eqExpr(inForInit));\n        }\n        return pn;\n    }\n\n    private Node eqExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = relExpr(inForInit);\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.EQ:\n              case Token.NE:\n              case Token.SHEQ:\n              case Token.SHNE:\n                consumeToken();\n                int decompilerToken = tt;\n                int parseToken = tt;\n                if (compilerEnv.getLanguageVersion() == Context.VERSION_1_2) {\n                    // JavaScript 1.2 uses shallow equality for == and != .\n                    // In addition, convert === and !== for decompiler into\n                    // == and != since the decompiler is supposed to show\n                    // canonical source and in 1.2 ===, !== are allowed\n                    // only as an alias to ==, !=.\n                    switch (tt) {\n                      case Token.EQ:\n                        parseToken = Token.SHEQ;\n                        break;\n                      case Token.NE:\n                        parseToken = Token.SHNE;\n                        break;\n                      case Token.SHEQ:\n                        decompilerToken = Token.EQ;\n                        break;\n                      case Token.SHNE:\n                        decompilerToken = Token.NE;\n                        break;\n                    }\n                }\n                decompiler.addToken(decompilerToken);\n                pn = nf.createBinary(parseToken, pn, relExpr(inForInit));\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node relExpr(boolean inForInit)\n        throws IOException, ParserException\n    {\n        Node pn = shiftExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.IN:\n                if (inForInit)\n                    break;\n                // fall through\n              case Token.INSTANCEOF:\n              case Token.LE:\n              case Token.LT:\n              case Token.GE:\n              case Token.GT:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, shiftExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node shiftExpr()\n        throws IOException, ParserException\n    {\n        Node pn = addExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.LSH:\n              case Token.URSH:\n              case Token.RSH:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, addExpr());\n                continue;\n            }\n            break;\n        }\n        return pn;\n    }\n\n    private Node addExpr()\n        throws IOException, ParserException\n    {\n        Node pn = mulExpr();\n        for (;;) {\n            int tt = peekToken();\n            if (tt == Token.ADD || tt == Token.SUB) {\n                consumeToken();\n                decompiler.addToken(tt);\n                // flushNewLines\n                pn = nf.createBinary(tt, pn, mulExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node mulExpr()\n        throws IOException, ParserException\n    {\n        Node pn = unaryExpr();\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n              case Token.MUL:\n              case Token.DIV:\n              case Token.MOD:\n                consumeToken();\n                decompiler.addToken(tt);\n                pn = nf.createBinary(tt, pn, unaryExpr());\n                continue;\n            }\n            break;\n        }\n\n        return pn;\n    }\n\n    private Node unaryExpr()\n        throws IOException, ParserException\n    {\n        int tt;\n\n        tt = peekToken();\n\n        switch(tt) {\n        case Token.VOID:\n        case Token.NOT:\n        case Token.BITNOT:\n        case Token.TYPEOF:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createUnary(tt, unaryExpr());\n\n        case Token.ADD:\n            consumeToken();\n            // Convert to special POS token in decompiler and parse tree\n            decompiler.addToken(Token.POS);\n            return nf.createUnary(Token.POS, unaryExpr());\n\n        case Token.SUB:\n            consumeToken();\n            // Convert to special NEG token in decompiler and parse tree\n            decompiler.addToken(Token.NEG);\n            return nf.createUnary(Token.NEG, unaryExpr());\n\n        case Token.INC:\n        case Token.DEC:\n            consumeToken();\n            decompiler.addToken(tt);\n            return nf.createIncDec(tt, false, memberExpr(true));\n\n        case Token.DELPROP:\n            consumeToken();\n            decompiler.addToken(Token.DELPROP);\n            return nf.createUnary(Token.DELPROP, unaryExpr());\n\n        case Token.ERROR:\n            consumeToken();\n            break;\n\n        // XML stream encountered in expression.\n        case Token.LT:\n            if (compilerEnv.isXmlAvailable()) {\n                consumeToken();\n                Node pn = xmlInitializer();\n                return memberExprTail(true, pn);\n            }\n            // Fall thru to the default handling of RELOP\n\n        default:\n            Node pn = memberExpr(true);\n\n            // Don't look across a newline boundary for a postfix incop.\n            tt = peekTokenOrEOL();\n            if (tt == Token.INC || tt == Token.DEC) {\n                consumeToken();\n                decompiler.addToken(tt);\n                return nf.createIncDec(tt, true, pn);\n            }\n            return pn;\n        }\n        return nf.createName(\"err\"); // Only reached on error.  Try to continue.\n\n    }\n\n    private Node xmlInitializer() throws IOException\n    {\n        int tt = ts.getFirstXMLToken();\n        if (tt != Token.XML && tt != Token.XMLEND) {\n            reportError(\"msg.syntax\");\n            return null;\n        }\n\n        /* Make a NEW node to append to. */\n        Node pnXML = nf.createLeaf(Token.NEW);\n        decompiler.addToken(Token.NEW);\n        decompiler.addToken(Token.DOT);\n\n        String xml = ts.getString();\n        boolean fAnonymous = xml.trim().startsWith(\"<>\");\n\n        decompiler.addName(fAnonymous ? \"XMLList\" : \"XML\");\n        Node pn = nf.createName(fAnonymous ? \"XMLList\" : \"XML\");\n        nf.addChildToBack(pnXML, pn);\n\n        pn = null;\n        Node expr;\n        for (;;tt = ts.getNextXMLToken()) {\n            switch (tt) {\n            case Token.XML:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                mustMatchToken(Token.LC, \"msg.syntax\");\n                decompiler.addToken(Token.LC);\n                expr = (peekToken() == Token.RC)\n                    ? nf.createString(\"\")\n                    : expr(false);\n                mustMatchToken(Token.RC, \"msg.syntax\");\n                decompiler.addToken(Token.RC);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n                int nodeType;\n                if (ts.isXMLAttribute()) {\n                    nodeType = Token.ESCXMLATTR;\n                } else {\n                    nodeType = Token.ESCXMLTEXT;\n                }\n                expr = nf.createUnary(nodeType, expr);\n                pn = nf.createBinary(Token.ADD, pn, expr);\n                break;\n            case Token.XMLEND:\n                xml = ts.getString();\n                decompiler.addString(xml);\n                if (pn == null) {\n                    pn = nf.createString(xml);\n                } else {\n                    pn = nf.createBinary(Token.ADD, pn, nf.createString(xml));\n                }\n\n                nf.addChildToBack(pnXML, pn);\n                return pnXML;\n            default:\n                reportError(\"msg.syntax\");\n                return null;\n            }\n        }\n    }\n\n    private void argumentList(Node listNode)\n        throws IOException, ParserException\n    {\n        boolean matched;\n        matched = matchToken(Token.RP);\n        if (!matched) {\n            boolean first = true;\n            do {\n                if (!first)\n                    decompiler.addToken(Token.COMMA);\n                first = false;\n                nf.addChildToBack(listNode, assignExpr(false));\n            } while (matchToken(Token.COMMA));\n\n            mustMatchToken(Token.RP, \"msg.no.paren.arg\");\n        }\n        decompiler.addToken(Token.RP);\n    }\n\n    private Node memberExpr(boolean allowCallSyntax)\n        throws IOException, ParserException\n    {\n        int tt;\n\n        Node pn;\n\n        /* Check for new expressions. */\n        tt = peekToken();\n        if (tt == Token.NEW) {\n            /* Eat the NEW token. */\n            consumeToken();\n            decompiler.addToken(Token.NEW);\n\n            /* Make a NEW node to append to. */\n            pn = nf.createCallOrNew(Token.NEW, memberExpr(false));\n\n            if (matchToken(Token.LP)) {\n                decompiler.addToken(Token.LP);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n            }\n\n            /* XXX there's a check in the C source against\n             * \"too many constructor arguments\" - how many\n             * do we claim to support?\n             */\n\n            /* Experimental syntax:  allow an object literal to follow a new expression,\n             * which will mean a kind of anonymous class built with the JavaAdapter.\n             * the object literal will be passed as an additional argument to the constructor.\n             */\n            tt = peekToken();\n            if (tt == Token.LC) {\n                nf.addChildToBack(pn, primaryExpr());\n            }\n        } else {\n            pn = primaryExpr();\n        }\n\n        return memberExprTail(allowCallSyntax, pn);\n    }\n\n    private Node memberExprTail(boolean allowCallSyntax, Node pn)\n        throws IOException, ParserException\n    {\n      tailLoop:\n        for (;;) {\n            int tt = peekToken();\n            switch (tt) {\n\n              case Token.DOT:\n              case Token.DOTDOT:\n                {\n                    int memberTypeFlags;\n                    String s;\n\n                    consumeToken();\n                    decompiler.addToken(tt);\n                    memberTypeFlags = 0;\n                    if (tt == Token.DOTDOT) {\n                        mustHaveXML();\n                        memberTypeFlags = Node.DESCENDANTS_FLAG;\n                    }\n                    if (!compilerEnv.isXmlAvailable()) {\n                        mustMatchToken(Token.NAME, \"msg.no.name.after.dot\");\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = nf.createPropertyGet(pn, null, s, memberTypeFlags);\n                        break;\n                    }\n\n                    tt = nextToken();\n                    switch (tt) {\n                      // handles: name, ns::name, ns::*, ns::[expr]\n                      case Token.NAME:\n                        s = ts.getString();\n                        decompiler.addName(s);\n                        pn = propertyName(pn, s, memberTypeFlags);\n                        break;\n\n                      // handles: *, *::name, *::*, *::[expr]\n                      case Token.MUL:\n                        decompiler.addName(\"*\");\n                        pn = propertyName(pn, \"*\", memberTypeFlags);\n                        break;\n\n                      // handles: '@attr', '@ns::attr', '@ns::*', '@ns::*',\n                      //          '@::attr', '@::*', '@*', '@*::attr', '@*::*'\n                      case Token.XMLATTR:\n                        decompiler.addToken(Token.XMLATTR);\n                        pn = attributeAccess(pn, memberTypeFlags);\n                        break;\n\n                      default:\n                        reportError(\"msg.no.name.after.dot\");\n                    }\n                }\n                break;\n\n              case Token.DOTQUERY:\n                consumeToken();\n                mustHaveXML();\n                decompiler.addToken(Token.DOTQUERY);\n                pn = nf.createDotQuery(pn, expr(false), ts.getLineno());\n                mustMatchToken(Token.RP, \"msg.no.paren\");\n                break;\n\n              case Token.LB:\n                consumeToken();\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, null, expr(false), 0);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                break;\n\n              case Token.LP:\n                if (!allowCallSyntax) {\n                    break tailLoop;\n                }\n                consumeToken();\n                decompiler.addToken(Token.LP);\n                pn = nf.createCallOrNew(Token.CALL, pn);\n                /* Add the arguments to pn, if any are supplied. */\n                argumentList(pn);\n                break;\n\n              default:\n                break tailLoop;\n            }\n        }\n        return pn;\n    }\n\n    /*\n     * Xml attribute expression:\n     *   '@attr', '@ns::attr', '@ns::*', '@ns::*', '@*', '@*::attr', '@*::*'\n     */\n    private Node attributeAccess(Node pn, int memberTypeFlags)\n        throws IOException\n    {\n        memberTypeFlags |= Node.ATTRIBUTE_FLAG;\n        int tt = nextToken();\n\n        switch (tt) {\n          // handles: @name, @ns::name, @ns::*, @ns::[expr]\n          case Token.NAME:\n            {\n                String s = ts.getString();\n                decompiler.addName(s);\n                pn = propertyName(pn, s, memberTypeFlags);\n            }\n            break;\n\n          // handles: @*, @*::name, @*::*, @*::[expr]\n          case Token.MUL:\n            decompiler.addName(\"*\");\n            pn = propertyName(pn, \"*\", memberTypeFlags);\n            break;\n\n          // handles @[expr]\n          case Token.LB:\n            decompiler.addToken(Token.LB);\n            pn = nf.createElementGet(pn, null, expr(false), memberTypeFlags);\n            mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n            decompiler.addToken(Token.RB);\n            break;\n\n          default:\n            reportError(\"msg.no.name.after.xmlAttr\");\n            pn = nf.createPropertyGet(pn, null, \"?\", memberTypeFlags);\n            break;\n        }\n\n        return pn;\n    }\n\n    /**\n     * Check if :: follows name in which case it becomes qualified name\n     */\n    private Node propertyName(Node pn, String name, int memberTypeFlags)\n        throws IOException, ParserException\n    {\n        String namespace = null;\n        if (matchToken(Token.COLONCOLON)) {\n            decompiler.addToken(Token.COLONCOLON);\n            namespace = name;\n\n            int tt = nextToken();\n            switch (tt) {\n              // handles name::name\n              case Token.NAME:\n                name = ts.getString();\n                decompiler.addName(name);\n                break;\n\n              // handles name::*\n              case Token.MUL:\n                decompiler.addName(\"*\");\n                name = \"*\";\n                break;\n\n              // handles name::[expr]\n              case Token.LB:\n                decompiler.addToken(Token.LB);\n                pn = nf.createElementGet(pn, namespace, expr(false),\n                                         memberTypeFlags);\n                mustMatchToken(Token.RB, \"msg.no.bracket.index\");\n                decompiler.addToken(Token.RB);\n                return pn;\n\n              default:\n                reportError(\"msg.no.name.after.coloncolon\");\n                name = \"?\";\n            }\n        }\n\n        pn = nf.createPropertyGet(pn, namespace, name, memberTypeFlags);\n        return pn;\n    }\n\n    private Node primaryExpr()\n        throws IOException, ParserException\n    {\n        Node pn;\n\n        int ttFlagged = nextFlaggedToken();\n        int tt = ttFlagged & CLEAR_TI_MASK;\n\n        switch(tt) {\n\n          case Token.FUNCTION:\n            return function(FunctionNode.FUNCTION_EXPRESSION);\n\n          case Token.LB: {\n            ObjArray elems = new ObjArray();\n            int skipCount = 0;\n            decompiler.addToken(Token.LB);\n            boolean after_lb_or_comma = true;\n            for (;;) {\n                tt = peekToken();\n\n                if (tt == Token.COMMA) {\n                    consumeToken();\n                    decompiler.addToken(Token.COMMA);\n                    if (!after_lb_or_comma) {\n                        after_lb_or_comma = true;\n                    } else {\n                        elems.add(null);\n                        ++skipCount;\n                    }\n                } else if (tt == Token.RB) {\n                    consumeToken();\n                    decompiler.addToken(Token.RB);\n                    break;\n                } else {\n                    if (!after_lb_or_comma) {\n                        reportError(\"msg.no.bracket.arg\");\n                    }\n                    elems.add(assignExpr(false));\n                    after_lb_or_comma = false;\n                }\n            }\n            return nf.createArrayLiteral(elems, skipCount);\n          }\n\n          case Token.LC: {\n            ObjArray elems = new ObjArray();\n            decompiler.addToken(Token.LC);\n            if (!matchToken(Token.RC)) {\n\n                boolean first = true;\n            commaloop:\n                do {\n                    Object property;\n\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    else\n                        first = false;\n\n                    tt = peekToken();\n                    switch(tt) {\n                      case Token.NAME:\n                      case Token.STRING:\n                        consumeToken();\n                        // map NAMEs to STRINGs in object literal context\n                        // but tell the decompiler the proper type\n                        String s = ts.getString();\n                        if (tt == Token.NAME) {\n                            decompiler.addName(s);\n                        } else {\n                            decompiler.addString(s);\n                        }\n                        property = ScriptRuntime.getIndexObject(s);\n                        break;\n\n                      case Token.NUMBER:\n                        consumeToken();\n                        double n = ts.getNumber();\n                        decompiler.addNumber(n);\n                        property = ScriptRuntime.getIndexObject(n);\n                        break;\n\n                      case Token.RC:\n                        // trailing comma is OK.\n                        break commaloop;\n                    default:\n                        reportError(\"msg.bad.prop\");\n                        break commaloop;\n                    }\n                    mustMatchToken(Token.COLON, \"msg.no.colon.prop\");\n\n                    // OBJLIT is used as ':' in object literal for\n                    // decompilation to solve spacing ambiguity.\n                    decompiler.addToken(Token.OBJECTLIT);\n                    elems.add(property);\n                    elems.add(assignExpr(false));\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RC, \"msg.no.brace.prop\");\n            }\n            decompiler.addToken(Token.RC);\n            return nf.createObjectLiteral(elems);\n          }\n\n          case Token.LP:\n\n            /* Brendan's IR-jsparse.c makes a new node tagged with\n             * TOK_LP here... I'm not sure I understand why.  Isn't\n             * the grouping already implicit in the structure of the\n             * parse tree?  also TOK_LP is already overloaded (I\n             * think) in the C IR as 'function call.'  */\n            decompiler.addToken(Token.LP);\n            pn = expr(false);\n            decompiler.addToken(Token.RP);\n            mustMatchToken(Token.RP, \"msg.no.paren\");\n            return pn;\n\n          case Token.XMLATTR:\n            mustHaveXML();\n            decompiler.addToken(Token.XMLATTR);\n            pn = attributeAccess(null, 0);\n            return pn;\n\n          case Token.NAME: {\n            String name = ts.getString();\n            if ((ttFlagged & TI_CHECK_LABEL) != 0) {\n                if (peekToken() == Token.COLON) {\n                    // Do not consume colon, it is used as unwind indicator\n                    // to return to statementHelper.\n                    // XXX Better way?\n                    return nf.createLabel(ts.getLineno());\n                }\n            }\n\n            decompiler.addName(name);\n            if (compilerEnv.isXmlAvailable()) {\n                pn = propertyName(null, name, 0);\n            } else {\n                pn = nf.createName(name);\n            }\n            return pn;\n          }\n\n          case Token.NUMBER: {\n            double n = ts.getNumber();\n            decompiler.addNumber(n);\n            return nf.createNumber(n);\n          }\n\n          case Token.STRING: {\n            String s = ts.getString();\n            decompiler.addString(s);\n            return nf.createString(s);\n          }\n\n          case Token.DIV:\n          case Token.ASSIGN_DIV: {\n            // Got / or /= which should be treated as regexp in fact\n            ts.readRegExp(tt);\n            String flags = ts.regExpFlags;\n            ts.regExpFlags = null;\n            String re = ts.getString();\n            decompiler.addRegexp(re, flags);\n            int index = currentScriptOrFn.addRegexp(re, flags);\n            return nf.createRegExp(index);\n          }\n\n          case Token.NULL:\n          case Token.THIS:\n          case Token.FALSE:\n          case Token.TRUE:\n            decompiler.addToken(tt);\n            return nf.createLeaf(tt);\n\n          case Token.RESERVED:\n            reportError(\"msg.reserved.id\");\n            break;\n\n          case Token.ERROR:\n            /* the scanner or one of its subroutines reported the error. */\n            break;\n\n          case Token.EOF:\n            reportError(\"msg.unexpected.eof\");\n            break;\n\n          default:\n            reportError(\"msg.syntax\");\n            break;\n        }\n        return null;    // should never reach here\n    }\n\n}"
+return.toString == "private Node function(int functionType)\n        throws IOException, ParserException\n    {\n        int syntheticType = functionType;\n        int baseLineno = ts.getLineno();  // line number where source starts\n\n        int functionSourceStart = decompiler.markFunctionStart(functionType);\n        String name;\n        Node memberExprNode = null;\n        if (matchToken(Token.NAME)) {\n            name = ts.getString();\n            decompiler.addName(name);\n            if (!matchToken(Token.LP)) {\n                if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                    // Extension to ECMA: if 'function <name>' does not follow\n                    // by '(', assume <name> starts memberExpr\n                    Node memberExprHead = nf.createName(name);\n                    name = \"\";\n                    memberExprNode = memberExprTail(false, memberExprHead);\n                }\n                mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n            }\n        } else if (matchToken(Token.LP)) {\n            // Anonymous function\n            name = \"\";\n        } else {\n            name = \"\";\n            if (compilerEnv.isAllowMemberExprAsFunctionName()) {\n                // Note that memberExpr can not start with '(' like\n                // in function (1+2).toString(), because 'function (' already\n                // processed as anonymous function\n                memberExprNode = memberExpr(false);\n            }\n            mustMatchToken(Token.LP, \"msg.no.paren.parms\");\n        }\n\n        if (memberExprNode != null) {\n            syntheticType = FunctionNode.FUNCTION_EXPRESSION;\n        }\n\n        boolean nested = insideFunction();\n\n        FunctionNode fnNode = nf.createFunction(name);\n        if (nested || nestingOfWith > 0) {\n            // 1. Nested functions are not affected by the dynamic scope flag\n            // as dynamic scope is already a parent of their scope.\n            // 2. Functions defined under the with statement also immune to\n            // this setup, in which case dynamic scope is ignored in favor\n            // of with object.\n            fnNode.itsIgnoreDynamicScope = true;\n        }\n\n        int functionIndex = currentScriptOrFn.addFunction(fnNode);\n\n        int functionSourceEnd;\n\n        ScriptOrFnNode savedScriptOrFn = currentScriptOrFn;\n        currentScriptOrFn = fnNode;\n        int savedNestingOfWith = nestingOfWith;\n        nestingOfWith = 0;\n        Hashtable savedLabelSet = labelSet;\n        labelSet = null;\n        ObjArray savedLoopSet = loopSet;\n        loopSet = null;\n        ObjArray savedLoopAndSwitchSet = loopAndSwitchSet;\n        loopAndSwitchSet = null;\n\n        Node body;\n        String source;\n        try {\n            decompiler.addToken(Token.LP);\n            if (!matchToken(Token.RP)) {\n                boolean first = true;\n                do {\n                    if (!first)\n                        decompiler.addToken(Token.COMMA);\n                    first = false;\n                    mustMatchToken(Token.NAME, \"msg.no.parm\");\n                    String s = ts.getString();\n                    if (fnNode.hasParamOrVar(s)) {\n                        addWarning(\"msg.dup.parms\", s);\n                    }\n                    fnNode.addParam(s);\n                    decompiler.addName(s);\n                } while (matchToken(Token.COMMA));\n\n                mustMatchToken(Token.RP, \"msg.no.paren.after.parms\");\n            }\n            decompiler.addToken(Token.RP);\n\n            mustMatchToken(Token.LC, \"msg.no.brace.body\");\n            decompiler.addEOL(Token.LC);\n            body = parseFunctionBody();\n            mustMatchToken(Token.RC, \"msg.no.brace.after.body\");\n\n            decompiler.addToken(Token.RC);\n            functionSourceEnd = decompiler.markFunctionEnd(functionSourceStart);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                 if (compilerEnv.getLanguageVersion() >= Context.VERSION_1_2) {\n                    // function f() {} function g() {} is not allowed in 1.2\n                    // or later but for compatibility with old scripts\n                    // the check is done only if language is\n                    // explicitly set.\n                    //  XXX warning needed if version == VERSION_DEFAULT ?\n                    int tt = peekTokenOrEOL();\n                    if (tt == Token.FUNCTION) {\n                         reportError(\"msg.no.semi.stmt\");\n                    }\n                 }\n                // Add EOL only if function is not part of expression\n                // since it gets SEMI + EOL from Statement in that case\n                decompiler.addToken(Token.EOL);\n            }\n        }\n        finally {\n            loopAndSwitchSet = savedLoopAndSwitchSet;\n            loopSet = savedLoopSet;\n            labelSet = savedLabelSet;\n            nestingOfWith = savedNestingOfWith;\n            currentScriptOrFn = savedScriptOrFn;\n        }\n\n        fnNode.setEncodedSourceBounds(functionSourceStart, functionSourceEnd);\n        fnNode.setSourceName(sourceURI);\n        fnNode.setBaseLineno(baseLineno);\n        fnNode.setEndLineno(ts.getLineno());\n\n        Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);\n        if (memberExprNode != null) {\n            pn = nf.createAssignment(Token.ASSIGN, memberExprNode, pn);\n            if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n                // XXX check JScript behavior: should it be createExprStatement?\n                pn = nf.createExprStatementNoReturn(pn, baseLineno);\n            }\n        }\n        return pn;\n    }"
 ===========================================================================
 rhino._1.Driver.hasCorrectInitFunctionPattern():::ENTER
 this has only one value
@@ -126,9 +131,9 @@
 this.parser has only one value
 this.sourceCode has only one value
 this.functionMethodBody has only one value
-return == false
+return == true
 ===========================================================================
-rhino._1.Driver.hasCorrectInitFunctionPattern():::EXIT;condition="not(return == true)"
+rhino._1.Driver.hasCorrectInitFunctionPattern():::EXIT;condition="return == true"
 ===========================================================================
 rhino._1.Driver.parse(java.lang.String, java.lang.String, int):::ENTER
 sourceURI has only one value
