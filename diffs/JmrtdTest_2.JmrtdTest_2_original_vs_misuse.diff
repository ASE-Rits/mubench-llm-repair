--- /dev/fd/63	2025-12-20 07:52:18.785051043 +0000
+++ /dev/fd/62	2025-12-20 07:52:18.784051017 +0000
@@ -37,21 +37,11 @@
 ===========================================================================
 jmrtd.JmrtdTest_2$PassportAuthServiceCases.PassportAuthServiceCases():::EXIT
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testCipherModeFromSource():::ENTER
-this has only one value
-===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testCipherModeFromSource():::EXIT
-===========================================================================
 jmrtd.JmrtdTest_2$PassportAuthServiceCases.testContainsPassportAuthService():::ENTER
 this has only one value
 ===========================================================================
 jmrtd.JmrtdTest_2$PassportAuthServiceCases.testContainsPassportAuthService():::EXIT
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testNotUsingEncryptMode():::ENTER
-this has only one value
-===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testNotUsingEncryptMode():::EXIT
-===========================================================================
 jmrtd.JmrtdTest_2$PassportAuthServiceCases.testRsaDecryptModeWorks():::ENTER
 this has only one value
 ===========================================================================
@@ -67,11 +57,6 @@
 ===========================================================================
 jmrtd.JmrtdTest_2$PassportAuthServiceCases.testSourceFileExists():::EXIT
 ===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testUsesDecryptMode():::ENTER
-this has only one value
-===========================================================================
-jmrtd.JmrtdTest_2$PassportAuthServiceCases.testUsesDecryptMode():::EXIT
-===========================================================================
 jmrtd._2.Driver:::OBJECT
 this.instance == this.open
 this.instance == this.aaCipherField
@@ -149,8 +134,8 @@
 jmrtd._2.Driver.containsPassportAuthService():::EXIT;condition="return == true"
 ===========================================================================
 jmrtd._2.Driver.findMethodEnd(java.lang.String, int):::ENTER
-sourceCode.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.DECRYPT_MODE, pubkey);\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
-methodStart == 1936
+sourceCode.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
+methodStart == 1934
 ===========================================================================
 jmrtd._2.Driver.findMethodEnd(java.lang.String, int):::EXIT
 ===========================================================================
@@ -180,8 +165,8 @@
 this.aaCipherField == orig(this.stateField)
 this.isPassportAuthService == orig(this.isPassportAuthService)
 sourceCode.toString == orig(sourceCode.toString)
-sourceCode.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.DECRYPT_MODE, pubkey);\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
-return == 9216
+sourceCode.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
+return == 9215
 ===========================================================================
 jmrtd._2.Driver.getCipherModeFromSource():::ENTER
 this has only one value
@@ -216,7 +201,7 @@
 this.isPassportAuthService == orig(this.isPassportAuthService)
 this.sourceFilePath has only one value
 return has only one value
-return.toString == "DECRYPT_MODE"
+return.toString == "ENCRYPT_MODE"
 ===========================================================================
 jmrtd._2.Driver.readSourceCode():::ENTER
 ===========================================================================
@@ -245,7 +230,7 @@
 this.aaCipherField == orig(this.aaCipherField)
 this.aaCipherField == orig(this.stateField)
 this.isPassportAuthService == orig(this.isPassportAuthService)
-return.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.DECRYPT_MODE, pubkey);\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
+return.toString == "/*\n * JMRTD - A Java API for accessing machine readable travel documents.\n *\n * Copyright (C) 2006  SoS group, Radboud University\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n *\n * $Id$\n */\n\npackage jmrtd._2.VARIANT;\n\nimport java.io.UnsupportedEncodingException;\nimport java.security.GeneralSecurityException;\nimport java.security.MessageDigest;\nimport java.security.PublicKey;\nimport java.security.Signature;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\n\nimport jmrtd._2.requirements.APDUListener;\nimport jmrtd._2.requirements.Apdu;\nimport jmrtd._2.requirements.CardService;\nimport jmrtd._2.requirements.Hex;\nimport jmrtd._2.requirements.PassportApduService;\nimport jmrtd._2.requirements.SecureMessagingWrapper;\nimport jmrtd._2.requirements.Util;\nimport jmrtd._2.requirements.BACEvent;\nimport jmrtd._2.requirements.AAEvent;\nimport jmrtd._2.requirements.AuthListener;\n\n/**\n * Card service for using the BAC and AA protocols on the passport.\n * Defines basic access control, active authentication.\n * \n * Based on ICAO-TR-PKI and ICAO-TR-LDS.\n * \n * Usage:\n *    <pre>\n *       &lt;&lt;create&gt;&gt; ==&gt; open() ==&gt; doBAC(...) ==&gt; doAA() ==&gt; close()\n *    </pre> \n *\n * @author Martijn Oostdijk (martijno@cs.ru.nl)\n *\n * @version $Revision$\n */\npublic class PassportAuthService implements CardService\n{\n   private static final int SESSION_STOPPED_STATE = 0;\n   private static final int SESSION_STARTED_STATE = 1;\n   private static final int BAC_AUTHENTICATED_STATE = 2;\n   private static final int AA_AUTHENTICATED_STATE = 3;\n   private int state;\n   \n   private Collection authListeners;\n\n   private PassportApduService service;\n   private SecureMessagingWrapper wrapper;\n   private Signature aaSignature;\n   private MessageDigest aaDigest = MessageDigest.getInstance(\"SHA1\");\n   private Cipher aaCipher = Cipher.getInstance(\"RSA\");\n\n   private PassportAuthService() throws GeneralSecurityException {\n      aaSignature = Signature.getInstance(\"SHA1WithRSA/ISO9796-2\"); /* FIXME: SHA1WithRSA also works? */\n      aaDigest = MessageDigest.getInstance(\"SHA1\");\n      aaCipher = Cipher.getInstance(\"RSA/NONE/NoPadding\");\n      authListeners = new ArrayList();\n   }\n   \n   /**\n    * Creates a new passport service for accessing the passport.\n    * \n    * @param service another service which will deal with sending\n    *        the apdus to the card.\n    *\n    * @throws GeneralSecurityException when the available JCE providers\n    *         cannot provide the necessary cryptographic primitives.\n    */\n   public PassportAuthService(CardService service)\n   throws GeneralSecurityException {\n      this();\n      if (service instanceof PassportAuthService) {\n         this.service = ((PassportAuthService)service).service;\n      } else if (service instanceof PassportApduService) {\n         this.service = (PassportApduService)service;\n      } else {\n         this.service = new PassportApduService(service);\n      }   \n      state = SESSION_STOPPED_STATE;\n   }\n   \n   /**\n    * Hack to construct a passport service from a service that is already open.\n    * This should be removed some day.\n    * \n    * @param service underlying service\n    * @param wrapper encapsulates secure messaging state\n    */\n   public PassportAuthService(CardService service, SecureMessagingWrapper wrapper)\n   throws GeneralSecurityException {\n      this(service);\n      this.wrapper = wrapper;\n      if (state < BAC_AUTHENTICATED_STATE) {\n         state = BAC_AUTHENTICATED_STATE;\n      }\n   }\n\n   /**\n    * Opens a session. This is done by connecting to the card, selecting the\n    * passport applet.\n    */\n   public void open() {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open();\n      state = SESSION_STARTED_STATE;\n   }\n   \n   public String[] getTerminals() {\n      return service.getTerminals();\n   }\n\n   public void open(String id) {\n      if (state == SESSION_STARTED_STATE) {\n         return;\n      }\n      service.open(id);\n      state = SESSION_STARTED_STATE;\n   }\n   \n   /**\n    * Performs the <i>Basic Access Control</i> protocol.\n    *\n    * @param docNr the document number\n    * @param dateOfBirth card holder's birth date\n    * @param dateOfExpiry document's expiry date\n    */\n   public void doBAC(String docNr, String dateOfBirth, String dateOfExpiry)\n         throws GeneralSecurityException, UnsupportedEncodingException {\n      byte[] keySeed = Util.computeKeySeed(docNr, dateOfBirth, dateOfExpiry);\n      SecretKey kEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey kMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      byte[] rndICC = service.sendGetChallenge();\n      byte[] rndIFD = new byte[8]; /* TODO: random */\n      byte[] kIFD = new byte[16]; /* TODO: random */\n      byte[] response = service.sendMutualAuth(rndIFD, rndICC, kIFD, kEnc, kMac);\n      byte[] kICC = new byte[16];\n      System.arraycopy(response, 16, kICC, 0, 16);\n      keySeed = new byte[16];\n      for (int i = 0; i < 16; i++) {\n         keySeed[i] = (byte) ((kIFD[i] & 0x000000FF) ^ (kICC[i] & 0x000000FF));\n      }\n      SecretKey ksEnc = Util.deriveKey(keySeed, Util.ENC_MODE);\n      SecretKey ksMac = Util.deriveKey(keySeed, Util.MAC_MODE);\n      long ssc = Util.computeSendSequenceCounter(rndICC, rndIFD);\n      wrapper = new SecureMessagingWrapper(ksEnc, ksMac, ssc);\n      notifyBACPerformed(wrapper, rndICC, rndIFD, kIFD, kICC, true);\n      state = BAC_AUTHENTICATED_STATE;\n   }\n   \n   public void addAuthenticationListener(AuthListener l) {\n      authListeners.add(l);\n   }\n   \n   public void removeAuthenticationListener(AuthListener l) {\n      authListeners.remove(l);\n   }\n   \n   protected void notifyBACPerformed(SecureMessagingWrapper wrapper,\n\t\t   byte[] rndICC, byte[] rndIFD, byte[] kICC, byte[] kIFD,\n\t\t   boolean success) {\n      BACEvent event = new BACEvent(this, wrapper, rndICC, rndIFD, kICC, kIFD, success);\n      Iterator it = authListeners.iterator();\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedBAC(event);\n      }\n  }\n\n   /**\n    * Performs the <i>Active Authentication</i> protocol.\n    * \n    * @param pubkey the public key to use (usually read from the card)\n    * \n    * @return a boolean indicating whether the card was authenticated\n    * \n    * @throws GeneralSecurityException if something goes wrong\n    */\n   public boolean doAA(PublicKey pubkey) throws GeneralSecurityException {\n      aaCipher.init(Cipher.ENCRYPT_MODE, pubkey);\n\n      aaSignature.initVerify(pubkey);\n      byte[] m2 = new byte[8]; /* TODO: random rndIFD */\n      byte[] response = service.sendInternalAuthenticate(wrapper, m2);\n      System.out.println(\"DEBUG: response.length = \" + response.length);\n      System.out.println(\"DEBUG: response = \" + Hex.bytesToHexString(response));\n      int digestLength = aaDigest.getDigestLength(); /* should always be 20 */\n      byte[] plaintext = aaCipher.doFinal(response);\n      byte[] m1 = Util.recoverMessage(digestLength, plaintext);\n      // System.out.println(\"DEBUG: m1 = \" + Hex.bytesToHexString(m1));\n      aaSignature.update(m1);\n      aaSignature.update(m2);\n      boolean success = aaSignature.verify(response);\n      notifyAAPerformed(pubkey, m1, m2, success);\n      if (success) {\n         state = AA_AUTHENTICATED_STATE;\n      }\n      return success;\n   }\n   \n   protected void notifyAAPerformed(PublicKey pubkey, byte[] m1, byte[] m2, boolean success) {\n      Iterator it = authListeners.iterator();\n      AAEvent event = new AAEvent(this, pubkey, m1, m2, success);\n      while (it.hasNext()) {\n          AuthListener listener = (AuthListener)it.next();\n          listener.performedAA(event);\n      }\n  }\n   \n   public byte[] sendAPDU(Apdu capdu) {\n      return service.sendAPDU(capdu);\n   }\n\n   public void close() {\n      try {\n         wrapper = null;\n         service.close();\n      } finally {\n         state = SESSION_STOPPED_STATE;\n      }\n   }\n\n   public void addAPDUListener(APDUListener l) {\n      service.addAPDUListener(l);\n   }\n\n   public void removeAPDUListener(APDUListener l) {\n      service.removeAPDUListener(l);\n   }\n   \n   public SecureMessagingWrapper getWrapper() {\n      return wrapper;\n   }\n   \n   /**\n    * @deprecated hack\n    * @param wrapper wrapper\n    */\n   public void setWrapper(SecureMessagingWrapper wrapper) {\n      this.wrapper = wrapper;\n      notifyBACPerformed(wrapper, null, null, null, null, true);\n   }\n}\n"
 ===========================================================================
 jmrtd._2.Driver.usesDecryptMode():::ENTER
 this has only one value
@@ -253,7 +238,7 @@
 ===========================================================================
 jmrtd._2.Driver.usesDecryptMode():::EXIT
 ===========================================================================
-jmrtd._2.Driver.usesDecryptMode():::EXIT;condition="return == true"
+jmrtd._2.Driver.usesDecryptMode():::EXIT;condition="not(return == true)"
 ===========================================================================
 jmrtd._2.Driver.usesDecryptMode():::EXIT
 this.targetClassName == orig(this.targetClassName)
@@ -279,12 +264,11 @@
 this.open == orig(this.notifyAAPerformed)
 this.aaCipherField == orig(this.aaCipherField)
 this.aaCipherField == orig(this.stateField)
-this.isPassportAuthService == return
-return == orig(this.isPassportAuthService)
+this.isPassportAuthService == orig(this.isPassportAuthService)
 this.sourceFilePath has only one value
-return == true
+return == false
 ===========================================================================
-jmrtd._2.Driver.usesDecryptMode():::EXIT;condition="return == true"
+jmrtd._2.Driver.usesDecryptMode():::EXIT;condition="not(return == true)"
 ===========================================================================
 jmrtd._2.Driver.usesEncryptMode():::ENTER
 this has only one value
@@ -292,7 +276,7 @@
 ===========================================================================
 jmrtd._2.Driver.usesEncryptMode():::EXIT
 ===========================================================================
-jmrtd._2.Driver.usesEncryptMode():::EXIT;condition="not(return == true)"
+jmrtd._2.Driver.usesEncryptMode():::EXIT;condition="return == true"
 ===========================================================================
 jmrtd._2.Driver.usesEncryptMode():::EXIT
 this.targetClassName == orig(this.targetClassName)
@@ -318,8 +302,9 @@
 this.open == orig(this.notifyAAPerformed)
 this.aaCipherField == orig(this.aaCipherField)
 this.aaCipherField == orig(this.stateField)
-this.isPassportAuthService == orig(this.isPassportAuthService)
+this.isPassportAuthService == return
+return == orig(this.isPassportAuthService)
 this.sourceFilePath has only one value
-return == false
+return == true
 ===========================================================================
-jmrtd._2.Driver.usesEncryptMode():::EXIT;condition="not(return == true)"
+jmrtd._2.Driver.usesEncryptMode():::EXIT;condition="return == true"
