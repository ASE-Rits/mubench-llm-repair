# Project: alibaba-druid / Case: 1

## original.java -> misuse.java
-import java.security.interfaces.RSAPrivateKey;
-import java.security.spec.RSAPublicKeySpec;
-            // 因为 IBM JDK 不支持私钥加密, 公钥解密, 所以要反转公私钥
-            // 也就是说对于解密, 可以通过公钥的参数伪造一个私钥对象欺骗 IBM JDK
-            RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
-            RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
-            Key fakePrivateKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
-            cipher = Cipher.getInstance("RSA"); //It is a stateful object. so we need to get new one.
-            cipher.init(Cipher.DECRYPT_MODE, fakePrivateKey);
+			// for ibm jdk
+			RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
+			RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
+			Key fakePublicKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
+			cipher.init(Cipher.DECRYPT_MODE, fakePublicKey);
-        try {
-		    cipher.init(Cipher.ENCRYPT_MODE, privateKey);
-        } catch (InvalidKeyException e) {
-            //For IBM JDK, 原因请看解密方法中的说明
-            RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;
-            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(rsaPrivateKey.getModulus(), rsaPrivateKey.getPrivateExponent());
-            Key publicKey = KeyFactory.getInstance("RSA").generatePublic(publicKeySpec);
-            cipher = Cipher.getInstance("RSA");
-            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
-        }
+		cipher.init(Cipher.ENCRYPT_MODE, privateKey);

## misuse.java -> fixed.java
+import java.nio.charset.StandardCharsets;
+
+
-		Cipher cipher = Cipher.getInstance("RSA");
+		if (cipherText == null || cipherText.length() == 0) {
+			return cipherText;
+		}
+
+		Cipher cipher;
+			cipher = Cipher.getInstance("RSA");
-			// for ibm jdk
+			cipher = Cipher.getInstance("RSA");
-		
-		if (cipherText == null || cipherText.length() == 0) {
-			return cipherText;
-		}
-		return new String(plainBytes);
+		return new String(plainBytes, StandardCharsets.UTF_8);
-
-		byte[] encryptedBytes = cipher.doFinal(plainText.getBytes("UTF-8"));
+		byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
-

## original.java -> fixed.java
+import java.nio.charset.StandardCharsets;
-import java.security.interfaces.RSAPrivateKey;
+
-import java.security.spec.RSAPublicKeySpec;
+
-		Cipher cipher = Cipher.getInstance("RSA");
+		if (cipherText == null || cipherText.length() == 0) {
+			return cipherText;
+		}
+
+		Cipher cipher;
+			cipher = Cipher.getInstance("RSA");
-            // 因为 IBM JDK 不支持私钥加密, 公钥解密, 所以要反转公私钥
-            // 也就是说对于解密, 可以通过公钥的参数伪造一个私钥对象欺骗 IBM JDK
-            RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
-            RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
-            Key fakePrivateKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
-            cipher = Cipher.getInstance("RSA"); //It is a stateful object. so we need to get new one.
-            cipher.init(Cipher.DECRYPT_MODE, fakePrivateKey);
-		}
-		
-		if (cipherText == null || cipherText.length() == 0) {
-			return cipherText;
+			RSAPublicKey rsaPublicKey = (RSAPublicKey) publicKey;
+			RSAPrivateKeySpec spec = new RSAPrivateKeySpec(rsaPublicKey.getModulus(), rsaPublicKey.getPublicExponent());
+			Key fakePublicKey = KeyFactory.getInstance("RSA").generatePrivate(spec);
+			cipher = Cipher.getInstance("RSA");
+			cipher.init(Cipher.DECRYPT_MODE, fakePublicKey);
-		return new String(plainBytes);
+		return new String(plainBytes, StandardCharsets.UTF_8);
-        try {
-		    cipher.init(Cipher.ENCRYPT_MODE, privateKey);
-        } catch (InvalidKeyException e) {
-            //For IBM JDK, 原因请看解密方法中的说明
-            RSAPrivateKey rsaPrivateKey = (RSAPrivateKey) privateKey;
-            RSAPublicKeySpec publicKeySpec = new RSAPublicKeySpec(rsaPrivateKey.getModulus(), rsaPrivateKey.getPrivateExponent());
-            Key publicKey = KeyFactory.getInstance("RSA").generatePublic(publicKeySpec);
-            cipher = Cipher.getInstance("RSA");
-            cipher.init(Cipher.ENCRYPT_MODE, publicKey);
-        }
-
-		byte[] encryptedBytes = cipher.doFinal(plainText.getBytes("UTF-8"));
+		cipher.init(Cipher.ENCRYPT_MODE, privateKey);
+		byte[] encryptedBytes = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
-
